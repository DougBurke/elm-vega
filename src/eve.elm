module Eve
    exposing
        ( APosition(..)
        , Arrangement(..)
        , AutosizeConfig(..)
        , AxisConfig(..)
        , AxisProperty(..)
        , BinProperty(..)
        , Binding(..)
        , CInterpolate(..)
        , Channel(..)
        , ConfigurationProperty(..)
        , DataValue(..)
        , DataValues(..)
        , DateTime(..)
        , DayName(..)
        , DetailChannel(..)
        , FDataType(..)
        , FacetChannel(..)
        , FacetMapping(..)
        , Filter(..)
        , FontWeight(..)
        , Format(..)
        , HAlign(..)
        , HeaderProperty(..)
        , InputProperty(..)
        , Legend(..)
        , LegendOrientation(..)
        , LegendProperty(..)
        , Mark(..)
        , MarkChannel(..)
        , MarkInterpolation(..)
        , MarkOrientation(..)
        , MarkProperty(..)
        , Measurement(..)
        , MonthName(..)
        , Operation(..)
        , OrderChannel(..)
        , OverlapStrategy(..)
        , Position(..)
        , PositionChannel(..)
        , Property
        , RangeConfig(..)
        , RepeatFields(..)
        , Resolution(..)
        , Resolve(..)
        , Scale(..)
        , ScaleConfig(..)
        , ScaleDomain(..)
        , ScaleNice(..)
        , ScaleProperty(..)
        , ScaleRange(..)
        , Selection(..)
        , SelectionMarkProperty(..)
        , SelectionProperty(..)
        , SelectionResolution(..)
        , Side(..)
        , SortProperty(..)
        , Spec
        , StackProperty(..)
        , Symbol(..)
        , TextChannel(..)
        , TimeUnit(..)
        , TitleConfig(..)
        , VAlign(..)
        , ViewConfig(..)
        , aggregate
        , asSpec
        , bin
        , calculate
        , categoricalDomainMap
        , color
        , column
        , configuration
        , configure
        , dataColumn
        , dataFromColumns
        , dataFromUrl
        , description
        , detail
        , domainRangeMap
        , encoding
        , facet
        , filter
        , hConcat
        , height
        , layer
        , mark
        , name
        , opAs
        , opacity
        , order
        , position
        , repeat
        , resolution
        , resolve
        , row
        , select
        , selection
        , shape
        , size
        , specification
        , text
        , title
        , toVegaLite
        , transform
        , vConcat
        , width
        )

{-| This library allows you to create Vega-Lite specifications in Elm. A specification
is stored as a JSON object which can be sent to a Vega-Lite interpreter to generate
the graphics. While this a 'pure' Elm library, to create the graphical output you
probably want to send a Vega-Lite specification generated by `toVegaLite` via a
port to some JavaScript that invokes the Vega-Lite runtime.


# Creating A Vega-Lite Specification

@docs toVegaLite
@docs Property


## General Data types

In addition to more general data types like integers and string, the following types
can carry data used in specifications.

@docs Spec
@docs DataValue
@docs DataValues
@docs DateTime
@docs MonthName
@docs DayName


# Creating the Data Specification

Functions for declaring the input data to the visualization.

@docs dataFromUrl
@docs dataFromColumns
@docs dataColumn
@docs Format
@docs FDataType


# Creating the Mark Specification

Types and functions for declaring the type of visual marks used in the visualization.

@docs mark
@docs Mark
@docs MarkProperty
@docs MarkOrientation
@docs MarkInterpolation
@docs Symbol


# Creating the Encoding Specification

Types and functions for declaring the encoding rules that map visual expression
to data. Channels can include position on screen (e.g. `X`,`Y`), visual mark properties
(e.g. colour, size, shape), text, ordering, level of detail and facets (for nested
visualization).

@docs encoding
@docs Measurement


## Position channels

Channels that relate to where something appears in the visualization.

@docs position
@docs PositionChannel
@docs Position
@docs SortProperty
@docs StackProperty
@docs AxisProperty
@docs OverlapStrategy
@docs Side
@docs HAlign
@docs VAlign
@docs FontWeight
@docs TimeUnit


## Mark channels

Channels that relate to the appearance of the visual marks in the visualization.

@docs size
@docs color
@docs opacity
@docs shape
@docs MarkChannel
@docs LegendProperty
@docs Legend
@docs LegendOrientation


## Text Channels

Channels that relate to the appearance of the text and tooltip elements of the
visualization.

@docs text
@docs TextChannel


## Order channels

Channels that relate to the order of data fields such as for sorting stacking order
or order of data points in a connected scatterplot. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#order)
for further details.

@docs order
@docs OrderChannel


## Facet channels

Channels for faceting single plots into small multiples. Can be used to create
trellis plots or other arrangements in rows and columns. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#facet)
for further details. See also, 'faceted view composition' for a more flexible (but
more verbose) way of defining faceted views.

@docs row
@docs column


## Level of detail Channel

Used for grouping data but without changing the visual appearance of a mark. When,
for example, a field is encoded by colour, all data items with the same value for
that field are given the same colour. When a detail channel encodes a field, all
data items with the same value are placed in the same group. This allows, for example
a line chart with multiple lines to be created â€“ one for each group. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#detail)
for more information.

@docs detail
@docs DetailChannel


# Creating the Transform Specification

Types and functions for declaring the transformation rules that are applied to
data or fields. Transformations may be applied to a number of different encodings,
such as position, colour and size.

@docs transform


## Aggregation

@docs aggregate
@docs Operation
@docs opAs


## Binning

@docs bin
@docs BinProperty


## Data Calculation

@docs calculate


## Filtering

@docs filter
@docs Filter


## Scaling

@docs ScaleProperty
@docs Scale
@docs categoricalDomainMap
@docs domainRangeMap
@docs ScaleDomain
@docs ScaleRange
@docs ScaleNice
@docs CInterpolate


# Creating view compositions

Views can be combined to create more complex multiview displays. This may involve
layering views on top of each other (superposition) or laying them out in adjacent
spaces (juxtaposition using `repeat`, `facet` or concatenate). Where different views
have potentially conflicting channels (for example, two position scales in a layered
visualization) the rules for resolving them can be defined with `resolve`. For details
of creating composite views see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/composition.html)

@docs layer
@docs hConcat
@docs vConcat
@docs resolve
@docs resolution
@docs Resolve
@docs Channel
@docs Resolution


## Faceted views

These are small multiples each of which show subsets of the same dataset. The specification
determines which field should be used to determine subsets along with their spatial
arrangement (in rows or columns). For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/facet.html)

@docs repeat
@docs RepeatFields
@docs facet
@docs FacetMapping
@docs FacetChannel
@docs asSpec
@docs specification
@docs Arrangement
@docs HeaderProperty


# Creating Selections for Interaction

Selections are the way in which interactions (such as clicking or dragging) can be
responded to in a visualization. They transform interactions into data queries.
For details, see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/selection.html).

@docs selection
@docs select
@docs Selection
@docs SelectionProperty
@docs Binding
@docs InputProperty
@docs SelectionResolution
@docs SelectionMarkProperty


## Making conditional channel encodings

Sometimes, especially when building interaction into a visualization, it is useful
to make channel encoding conditional on some kind of selection such as clicking
or dragging. Once a selection has been defined and named, supplying a set of
`MCondition` encodings allow mark encodings to become dependent on that selection.
`MCondition` is followed firstly by the name of the selection upon which it is
dependent, then an 'if' and an 'else' clause. Each clause is a list of mark field
encodings that should be applied when the selection is true (the 'if clause') and
when it is false (the 'else clause'). The colour encoding below is saying "whenever
data marks are selected with an interval mouse drag, encode the cylinder field with
an ordinal colour scheme, else make them grey".

      sel =
          selection << select "myBrush" Interval []

      enc =
          encoding
              << position X [ PName "Horsepower", PmType Quantitative ]
              << position Y [ PName "Miles_per_Gallon", PmType Quantitative ]
              << color
                  [ MCondition "myBrush"
                      [ MName "Cylinders", MmType Ordinal ]
                      [ MString "grey" ]
                  ]

For details, see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/condition.html).


# Global Configuration

Configuration options that affect the entire visualization. These are in addition
to the data and transform options described above.
@docs name
@docs title
@docs description
@docs height
@docs width
@docs configure
@docs configuration
@docs ConfigurationProperty
@docs AutosizeConfig
@docs AxisConfig
@docs ScaleConfig
@docs TitleConfig
@docs APosition
@docs ViewConfig
@docs RangeConfig

-}

import Json.Decode as JD
import Json.Encode as JE


{-| Indicates the anchor position for some text.
-}
type APosition
    = AStart
    | AMiddle
    | AEnd


{-| Idenfies whether a repeated/faceted view is arranged in rows or columns.
-}
type Arrangement
    = Column
    | Row


{-| Indicates the auto-sizing characteristics of the visualization such as amount
of padding, whether it should fill the parent container etc. For more details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
-}
type AutosizeConfig
    = AContent
    | AFit
    | ANone
    | APad
    | APadding
    | AResize Bool


{-| Axis configuration options for customising all axes. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/axis.html#general-config)
for more details.
-}
type AxisConfig
    = BandPosition Float
    | DomainColor String
    | DomainWidth Float
    | GridColor String
    | GridDash (List Float)
    | GridOpacity Float
    | GridWidth Float
    | LabelColor String
    | LabelFont String
    | LabelFontSize Float
    | LabelLimit Float
    | ShortTimeLabels Bool
    | TickColor String
    | TickRound Bool
    | TickWidth Float
    | TitleBaseline VAlign
    | TitleColor String
    | TitleFont String
    | TitleFontWeight FontWeight
    | TitleFontSize Float
    | TitleLimit Float
    | TitleX Float
    | TitleY Float


{-| Axis customisation properties. These are used for customising individual axes.
To configure all axes, use `AxisConfig` with a `configuration` instead. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/axis.html#axis-properties)
for more details.
-}
type AxisProperty
    = Domain Bool
    | Format String
    | Grid Bool
    | LabelAngle Float
    | LabelOverlap OverlapStrategy
    | LabelPadding Float
    | Labels Bool
    | MaxExtent Float
    | MinExtent Float
    | Offset Float
    | Orient Side
    | Position Float
    | Ticks Bool
    | TickCount Int
    | TickSize Float
    | AxTitle String
    | AxTitleAlign HAlign
    | AxTitleAngle Float
    | AxTitleMaxLength Float
    | AxTitlePadding Float
    | Values (List Float)
    | ZIndex Int


{-| Type of binning property to customise. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/bin.html) for
more details.
-}
type BinProperty
    = Base Float
    | Divide Float Float
    | Extent Float Float
    | MaxBins Int
    | MinStep Float
    | Nice Bool
    | Step Float
    | Steps (List Float)


{-| Describes the binding property of a selection based on some HTML input element
such as a checkbox or radio button. For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/bind.html#scale-binding)
and the [Vega input binding documentation](https://vega.github.io/vega/docs/signals/#bind)
-}
type Binding
    = InRange String (List InputProperty)
    | InCheckbox String (List InputProperty)
    | InRadio String (List InputProperty)
    | InSelect String (List InputProperty)
      -- TODO: Check validity: The following input types can generate a warning if options are included even if options appear to have an effect (e.g. placeholder)
    | InText String (List InputProperty)
    | InNumber String (List InputProperty)
    | InDate String (List InputProperty)
    | InTime String (List InputProperty)
    | InMonth String (List InputProperty)
    | InWeek String (List InputProperty)
    | InDateTimeLocal String (List InputProperty)
    | InTel String (List InputProperty)
    | InColor String (List InputProperty)


{-| Indicates a channel type to be used in a resolution specification.
-}
type Channel
    = ChX
    | ChY
    | ChX2
    | ChY2
    | ChColor
    | ChOpacity
    | ChShape
    | ChSize


{-| Indicates the type of colour interpolation to apply, when mapping a data field
onto a colour scale. Note that color interpolation cannot be applied with the default
`sequential` color scale, so additionally, you should set the `SType` to another
continuous scale such as `linear`, `pow` etc.

Of the interpolation options below `Rgb`, `CubeHelix` and `CubeHelixLong` also require
a `gamma` value (with 1 being a recommended default to provide). For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html#continuous).

-}
type CInterpolate
    = CubeHelix Float
    | CubeHelixLong Float
    | Hcl
    | HclLong
    | Hsl
    | HslLong
    | Lab
    | Rgb Float


{-| Type of configuration property to customise. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html)
for details.
-}
type ConfigurationProperty
    = AreaStyle (List MarkProperty)
    | Autosize AutosizeConfig
    | Axis (List AxisConfig)
    | AxisX (List AxisConfig)
    | AxisY (List AxisConfig)
    | AxisLeft (List AxisConfig)
    | AxisRight (List AxisConfig)
    | AxisTop (List AxisConfig)
    | AxisBottom (List AxisConfig)
    | AxisBand (List AxisConfig)
    | Background String
    | BarStyle (List MarkProperty)
    | CircleStyle (List MarkProperty)
    | CountTitle String
    | Legend (List LegendProperty)
    | LineStyle (List MarkProperty)
    | MarkStyle (List MarkProperty)
    | NamedStyle String (List MarkProperty)
    | NumberFormat String
    | Padding Float Float Float Float
    | PointStyle (List MarkProperty)
    | Range (List RangeConfig)
    | RectStyle (List MarkProperty)
    | RemoveInvalid Bool
    | RuleStyle (List MarkProperty)
    | Scale (List ScaleConfig)
      -- TODO: Add Selecion config
    | SquareStyle (List MarkProperty)
    | Style (List MarkProperty)
    | TextStyle (List MarkProperty)
    | TickStyle (List MarkProperty)
    | TitleStyle (List TitleConfig)
    | TimeFormat String
    | View (List ViewConfig)


{-| A single data value. This is used when a function can accept values of different
types (e.g. either a number or a string).
-}
type DataValue
    = Boolean Bool
    | DT (List DateTime)
    | Number Float
    | Str String


{-| A list of data values. This is used when a function can accept lists of
different types (e.g. either a list of numbers or a list of strings).
-}
type DataValues
    = Booleans (List Bool)
    | DateTimes (List (List DateTime))
    | Numbers (List Float)
    | Strings (List String)


{-| Allows a date or time to be represented. This is typically part of a list of
`DateTime` items to provide a specific point in time. For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/types.html#datetime).
-}
type DateTime
    = DTYear Int
    | DTQuarter Int
    | DTMonth MonthName
    | DTDate Int
    | DTDay DayName
    | DTHours Int
    | DTMinutes Int
    | DTSeconds Int
    | DTMilliseconds Int


{-| Identifies the day of the week.
-}
type DayName
    = Mon
    | Tue
    | Wed
    | Thu
    | Fri
    | Sat
    | Sun


{-| Level of detail channel properties used for creating a grouped channel encoding.
-}
type DetailChannel
    = DName String
    | DmType Measurement
    | DBin (List BinProperty)
    | DTimeUnit TimeUnit
    | DAggregate Operation



-- {-| Interaction events to support selection. For further details, see the
-- [Vega documentation](https://vega.github.io/vega/docs/event-streams).
-- -}
-- type Event
--     = Click
--     | DblClick
--     | DragEnter
--     | DragLeave
--     | DragOver
--     | KeyDown
--     | KeyPress
--     | KeyUp
--     | MouseDown
--     | MouseMove
--     | MouseOut
--     | MouseOver
--     | MouseUp
--     | MouseWheel
--     | TouchEnd
--     | TouchMove
--     | TouchStart
--     | Wheel


{-| Types of facet channel property used for creating a composed facet view of small
multiples.
-}
type FacetChannel
    = FName String
    | FmType Measurement
    | FBin (List BinProperty)
    | FAggregate Operation
    | FTimeUnit TimeUnit
    | FHeader (List HeaderProperty)


{-| Provides details of the mapping between a row or column and its field
definitions in a set of faceted small multiples. For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/facet.html#mapping)
-}
type FacetMapping
    = ColumnBy (List FacetChannel)
    | RowBy (List FacetChannel)


{-| Indicates the type of data to be parsed when reading input data. For `FDate`
and `FUtc`, the formatting specification can be specified using
[D3's formatting specifiers](https://vega.github.io/vega-lite/docs/data.html#format)
or left as an empty string if default date formatting is to be applied. Care should
be taken when assuming default passing of dates though as different browsers can
parse dates differently. Being explicit about the date format is usually safer.
-}
type FDataType
    = FNumber
    | FBoolean
    | FDate String
    | FUtc String


{-| Type of filtering operation. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/filter.html)
for details.
-}
type Filter
    = FEqual String DataValue
    | FExpr String
    | FSelection String
    | FOneOf String DataValues
    | FRange String DataValues


{-| Specifies the type of format a data source uses. For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format).
-}
type Format
    = JSON
    | CSV
    | TSV
    | TopojsonFeature String
    | TopojsonMesh String
    | Parse (List ( String, FDataType ))


{-| Indicates the weight options for a font.
-}
type FontWeight
    = Bold
    | Bolder
    | Lighter
    | Normal
    | W100
    | W200
    | W300
    | W400
    | W500
    | W600
    | W700
    | W800
    | W900


{-| Indicates the horizontal alignment of some text such as on an axis or legend.
-}
type HAlign
    = AlignCenter
    | AlignLeft
    | AlignRight


{-| Represents a facet header property. For details, see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/facet.html#header)
-}
type HeaderProperty
    = HFormat String
    | HTitle String


{-| GUI Input properties. The type of relevant proerty will depend on the type of
input element selected. For example an `InRange` (slider) can have numeric min,
max and step values; InSelect (selector) has a list of selection label options.
For details see the
[Vega input element binding documentation](https://vega.github.io/vega/docs/signals/#bind).
The `debounce` property, available for all input types allows a delay in input event
handling to be added in order to avoid unnecessary event broadcasting. The `Element`
property is an optional CSS selector indicating the parent element to which the
input element should be added. This allows the option of the input element to be
outside the visualization container.
-}
type InputProperty
    = Debounce Float
    | Element String
    | InOptions (List String)
    | InMin Float
    | InMax Float
    | InStep Float
    | InPlaceholder String


{-| Indicates the type of legend to create. Gradient legends are usually used for
continuous quantitative data while symbol legends used for categorical data.
-}
type Legend
    = Gradient
    | Symbol


{-| Indicates the legend orientation. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/legend.html#config)
for more details.
-}
type LegendOrientation
    = BottomLeft
    | BottomRight
    | Left
    | None
    | Right
    | TopLeft
    | TopRight


{-| Legend configuration options. For more detail see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html#legend-config).
-}
type LegendProperty
    = LEntryPadding Float
    | LFormat String
    | LOffset Float
    | LOrient LegendOrientation
    | LPadding Float
    | LTickCount Float
    | LTitle String
    | LType Legend
    | LValues DataValues
    | LZIndex Int


{-| Type of visual mark used to represent data in the visualization.
-}
type Mark
    = Area
    | Bar
    | Circle
    | Line
    | Point
    | Rect
    | Rule
    | Square
    | Text
    | Tick


{-| Indicates mark interpolation style. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/mark.html#mark-def)
for details.
-}
type MarkInterpolation
    = Basis
    | BasisClosed
    | BasisOpen
    | Bundle
    | Cardinal
    | CardinalClosed
    | CardinalOpen
    | Linear
    | LinearClosed
    | Monotone
    | StepAfter
    | StepBefore
    | Stepwise


{-| Mark channel properties used for creating a mark channel encoding.
-}
type MarkChannel
    = MName String
    | MRepeat Arrangement
    | MmType Measurement
    | MScale (List ScaleProperty)
    | MBin (List BinProperty)
    | MTimeUnit TimeUnit
    | MAggregate Operation
    | MLegend (List LegendProperty)
    | MCondition String (List MarkChannel) (List MarkChannel)
    | MNumber Float
    | MString String
    | MBoolean Bool


{-| Indicates desired orientation of a mark (e.g. horizontally or vertically
oriented bars.)
-}
type MarkOrientation
    = Horizontal
    | Vertical


{-| Properties for customising the appearance of a mark. For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/mark.html#config).
-}
type MarkProperty
    = MAlign HAlign
    | MAngle Float
    | MBandSize Float
    | MBaseline VAlign
    | MBinSpacing Float
    | MClip Bool
    | MColor String
    | MContinuousBandSize Float
    | MDiscreteBandSize Float
    | MdX Float
    | MdY Float
    | MFill String
    | MFilled Bool
    | MFillOpacity Float
    | MFont String
    | MFontSize Float
    | MFontStyle String
    | MFontWeight FontWeight
    | MInterpolate MarkInterpolation
    | MOpacity Float
    | MOrient MarkOrientation
    | MRadius Float
    | MShape Symbol
    | MShortTimeLabels Bool
    | MSize Float
    | MStroke String
    | MStrokeDash (List Float)
    | MStrokeDashOffset Float
    | MStrokeOpacity Float
    | MStrokeWidth Float
    | MStyle (List String)
    | MTension Float
    | MText String
    | MTheta Float
    | MThickness Float


{-| Level of measurement to be associated with some channel. `Nominal` data are
categories identified by name alone and which have no intrinsic order. `Ordinal`
data are also categories, but ones which have some natural order. `Quantitative`
data are numeric measurements typcially on a continuous scale. `Temporal` data
describe time.
-}
type Measurement
    = Nominal
    | Ordinal
    | Quantitative
    | Temporal


{-| Idntifies a month of the year.
-}
type MonthName
    = Jan
    | Feb
    | Mar
    | Apr
    | May
    | Jun
    | Jul
    | Aug
    | Sep
    | Oct
    | Nov
    | Dec


{-| Type of aggregation operation. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/aggregate.html#ops)
for more details.
-}
type
    Operation
    -- TODO: Add argmin and argmax (parameterised options)
    = Average
    | CI0
    | CI1
    | Count
    | Distinct
    | Max
    | Mean
    | Median
    | Min
    | Missing
    | Q1
    | Q3
    | Stderr
    | Stdev
    | StdevP
    | Sum
    | Valid
    | Variance
    | VarianceP


{-| Properties of an ordering channel used for sorting data fields.
-}
type OrderChannel
    = OName String
    | ORepeat Arrangement
    | OmType Measurement
    | OBin (List BinProperty)
    | OAggregate Operation
    | OTimeUnit TimeUnit
    | OSort (List SortProperty)


{-| Type of overlap strategy to be applied when there is not space to show all items
on an axis. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/axis.html#labels)
for more details.
-}
type OverlapStrategy
    = ONone
    | OParity
    | OGreedy


{-| Type of position channel, `X` and `Y` represent horizontal and vertical axis dimensions
while `X2` and `Y2` represent secondary axis dimensions where two scales are overlaid
in the same space.
-}
type Position
    = X
    | Y
    | X2
    | Y2


{-| Position channel properties used for creating a position channel encoding.
-}
type PositionChannel
    = PName String
    | PRepeat Arrangement
    | PmType Measurement
    | PBin (List BinProperty)
    | PTimeUnit TimeUnit
    | PAggregate Operation
    | PScale (List ScaleProperty)
    | PAxis (List AxisProperty)
    | PSort (List SortProperty)
    | PStack StackProperty


{-| Top-level Vega-Lite properties. These are the ones that define the visualization.
They are generated by functions such as `mark`, `transform`, `dataFromUrl` etc.
Commonly you will define at least the data property (providing the data to visualize);
the mark property (the form of visual symbolisation to use); and the encoding property
(the rules that map the data to the marks).

Other property generating functions include `selection` for interaction, and `transform`
for data transformations. More global properties of the entire visualization
may be specified with the `configure`, `width` and `height`.

Properties can be nested inside specifications such as layers or adjacently concatenated
visualizations that contain further properties. This allows several specifications
to be layered in the same graphical space or juxtaposed in rows and columns.

-}
type Property
    = Name
    | Description
    | Title
    | Width
    | Height
    | Data
    | Mark
    | Transform
    | Encoding
    | Layer
    | HConcat
    | VConcat
    | Repeat
    | Facet
    | Spec
    | Resolve
    | Config
    | Selection


{-| Properties for customising the colours of a range. The parameter should be a
named colour scheme such as `accent` or `purpleorange-11`. For details see the
[Vega-Lite documentation](https://vega.github.io/vega/docs/schemes/#scheme-properties).
-}
type RangeConfig
    = RCategory String
    | RDiverging String
    | RHeatmap String
    | ROrdinal String
    | RRamp String
    | RSymbol String


{-| Create a list of fields to use in set of repeated small multiples. The list of
fields named here can be referenced in an encoding with `PRepeat Column`, `PRepeat Row`
etc.
-}
type RepeatFields
    = RowFields (List String)
    | ColumnFields (List String)


{-| Indicated whether or not a scale domain should be independent of others in a
composite visualization. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/resolve.html) for
details.
-}
type Resolution
    = Shared
    | Independent


{-| Used to determine how a channel's axis, scale or legend domains should be resolved
if defined in more than one view in a composite visualization. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/resolve.html) for
details.
-}
type Resolve
    = RAxis (List ( Channel, Resolution ))
    | RLegend (List ( Channel, Resolution ))
    | RScale (List ( Channel, Resolution ))


{-| Used to indicate the type of scale transformation to apply.
-}
type Scale
    = ScLinear
    | ScPow
    | ScSqrt
    | ScLog
    | ScTime
    | ScUtc
    | ScSequential
    | ScOrdinal
    | ScBand
    | ScPoint
    | ScBinLinear
    | ScBinOrdinal


{-| Scale configuration property. These are used to configure all scales.
For more details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html#scale-config)
-}
type ScaleConfig
    = SCBandPaddingInner Float
    | SCBandPaddingOuter Float
    | SCClamp Bool
    | SCMaxBandSize Float
    | SCMinBandSize Float
    | SCMaxFontSize Float
    | SCMinFontSize Float
    | SCMaxOpacity Float
    | SCMinOpacity Float
    | SCMaxSize Float
    | SCMinSize Float
    | SCMaxStrokeWidth Float
    | SCMinStrokeWidth Float
    | SCPointPadding Float
    | SCRangeStep (Maybe Float)
    | SCRound Bool
    | SCTextXRangeStep Float
    | SCUseUnaggregatedDomain Bool


{-| Describes the scale domain (type of data in scale). For full details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html#domain).
-}
type ScaleDomain
    = DNumbers (List Float)
    | DStrings (List String)
    | DDateTimes (List (List DateTime))
    | DSelection String
    | Unaggregated


{-| Describes the way a scale can be rounded to 'nice' numbers. For full details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html#continuous).
-}
type ScaleNice
    = NMillisecond
    | NSecond
    | NMinute
    | NHour
    | NDay
    | NWeek
    | NMonth
    | NYear
      -- TODO: Time interval object
    | IsNice Bool
    | NTickCount Int


{-| Individual scale property. These are used to customise an individual scale
transformation. To customise all scales use `config` and supply relevant
`ScaleConfig` values. For more details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html)
-}
type ScaleProperty
    = SType Scale
    | SDomain ScaleDomain
    | SRange ScaleRange
    | SScheme String (List Float)
    | SPadding Float
    | SPaddingInner Float
    | SPaddingOuter Float
    | SRangeStep (Maybe Float)
    | SRound Bool
    | SClamp Bool
      -- TODO:  Need to restrict set of valid scale types that work with colour interpolation
    | SInterpolate CInterpolate
    | SNice ScaleNice
    | SZero Bool
      -- TODO: Check: This is a Vega, not Vega-Lite property so can generate a warning if validated against the Vega-Lite spec.
    | SReverse Bool


{-| Describes a scale range of scale output values. For full details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html#range).
-}
type ScaleRange
    = RNumbers (List Float)
    | RStrings (List String)
    | RName String


{-| Indicates the type of selection to be generated by the user. `Single` allows
one mark at a time to be selected. 'Multi' allows multiple items to be selected
(e.g. with shift-click). 'Interval' allows a bounding rectangle to be dragged by
user to select all items intersecting with it.
-}
type Selection
    = Single
    | Multi
    | Interval


{-| Properties for customising the appearance of an interval selection mark (dragged
rectangle). For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/selection.html#interval-mark).
-}
type SelectionMarkProperty
    = SMFill String
    | SMFillOpacity Float
    | SMStroke String
    | SMStrokeOpacity Float
    | SMStrokeWidth Float
    | SMStrokeDash (List Float)
    | SMStrokeDashOffset Float


{-| Properties for customising the nature of the selection. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/selection.html#selection-properties)
for details. When linking a selection property to an event stream with `On`, `Translate`
or `Zoom`, a String should be provided describing the event stream as detailed in the
[Vega event stream documentation](https://vega.github.io/vega/docs/event-streams/).
If an empty string is provided, the property is set to `false`.
-}
type SelectionProperty
    = On String
    | Translate String
    | Zoom String
    | Fields (List String)
    | Encodings (List Channel)
    | Empty
    | ResolveSelections SelectionResolution
    | SelectionMark (List SelectionMarkProperty)
    | BindScales
    | Bind (List Binding)
    | Nearest Bool
      -- TODO: XXXX Add toggle vega expression option
    | NoToggle


{-| Determines how selections in faceted or repeated views are resolved. See the
[Vege-Lite documentation](https://vega.github.io/vega-lite/docs/selection.html#resolve)
for details
-}
type SelectionResolution
    = Global
    | Union
    | Intersection


{-| Represents one side of a rectangular space.
-}
type Side
    = STop
    | SBottom
    | SLeft
    | SRight


{-| Allow type of sorting to be customised. For details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/sort.html).
-}
type SortProperty
    = Ascending
    | Descending
    | Op Operation
      -- TODO: Do we need a NoSort option?
    | ByField String
    | ByRepeat Arrangement


{-| Represents a Vega-Lite specification. Specs can be (and usually are) nested.
They can range from a single Boolean value up to the entire Vega-Lite specification.
-}
type alias Spec =
    JE.Value


{-| Describes the type of stacking to apply to a bar chart.
-}
type StackProperty
    = StZero
    | StNormalize
    | StCenter
    | NoStack


{-| Identifies the type of symbol. The `Path` symbol is used to define custom shapes
as an SVG path description.
-}
type Symbol
    = SymCircle
    | SymSquare
    | Cross
    | Diamond
    | TriangleUp
    | TriangleDown
    | Path String


{-| Types of text channel property used for displaying text as part of the visualization.
-}
type TextChannel
    = TName String
    | TRepeat Arrangement
    | TmType Measurement
    | TBin (List BinProperty)
    | TAggregate Operation
    | TTimeUnit TimeUnit
      -- TODO: Add ConditionValueDef
    | TFormat String


{-| Describes a unit of time. Useufl for encoding and transformations. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/timeunit.html)
for further details.
-}
type TimeUnit
    = Year
    | YearQuarter
    | YearQuarterMonth
    | YearMonth
    | YearMonthDate
    | YearMonthDateHours
    | YearMonthDateHoursMinutes
    | YearMonthDateHoursMinutesSeconds
    | Quarter
    | QuarterMonth
    | Month
    | MonthDate
    | Date
    | Day
    | Hours
    | HoursMinutes
    | HoursMinutesSeconds
    | Minutes
    | MinutesSeconds
    | Seconds
    | SecondsMilliseconds
    | Milliseconds


{-| Title configuration properties. These are used to configure the default style
of all titles within a visualization.
For further details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/title.html#config)
-}
type TitleConfig
    = TAnchor APosition
    | TAngle Float
    | TBaseline VAlign
    | TColor String
    | TFont String
    | TFontSize Float
    | TFontWeight FontWeight
    | TLimit Float
    | TOffset Float
    | TOrient Side


{-| Indicates the vertical alignment of some text that may be attached to a mark.
-}
type VAlign
    = AlignTop
    | AlignMiddle
    | AlignBottom


{-| View configuration property. These are used to configure the style of a single
view within a visualization such as its size and default fill and stroke colours.
For further details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/spec.html#config)
-}
type ViewConfig
    = VWidth Float
    | VHeight Float
    | Clip Bool
    | Fill (Maybe String)
    | FillOpacity (Maybe Float)
    | Stroke (Maybe String)
    | StrokeOpacity (Maybe Float)
    | StrokeWidth (Maybe Float)
    | StrokeDash (Maybe (List Float))
    | StrokeDashOffset (Maybe Float)


{-| Defines a set of named aggregation transformations to be used when encoding
channels. This is useful when, for example, you wish to apply the same transformation
to a number of channels but do not want to define it each time. The first parameter is
a list of the named aggregation operations to apply. The second parameter is a list
of 'group by' fields. The third parameter is the list of transformations to which
this is to be added. For further details see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/aggregate.html#aggregate-op-def).

    trans =
        transform
            << aggregate
                [ opAs Min "people" "lowerBound", opAs Max "people" "upperBound" ]
                [ "age" ]

-}
aggregate : List Spec -> List String -> List LabelledSpec -> List LabelledSpec
aggregate ops groups =
    (::) ( "aggregate", JE.list [ JE.list ops, JE.list (List.map JE.string groups) ] )


{-| Create a specification sufficient to define an element in a composed visualization
such as a superposed layer or juxtaposed facet. Typically a layer will contain a
full set of specifications that define a visualization with
the exception of the data specification which is usually defined outside of any one
layer. Whereas for repeated and faceted specs, the entire specification is provided.

    enc1 = ...
    spec1 =
        asSpec [ enc1, mark Line [] ]

-}
asSpec : List ( Property, Spec ) -> Spec
asSpec specs =
    List.map (\( s, v ) -> ( propertyLabel s, v )) specs
        |> JE.object


{-| Creates a binning transformation that can be applied to a channel. The type
of binning can be customised with a list of `BinProperty` or an empty list to use
the default binning. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/bin.html) for
more details.

    position X [ PName "IMDB_Rating", PmType Quantitative , bin [] ]

-}
bin : List BinProperty -> LabelledSpec
bin bProps =
    if bProps == [] then
        ( "bin", JE.bool True )
    else
        ( "bin", bProps |> List.map binProperty |> JE.object )


{-| Creates a new data field based on calculations from existing fields.
The first parameter is an expression representing the calculation and the second
is the name to give the newly calculated field. This third parameter is a list of
any previous calculations to which this is to be added. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/calculate.html)
for further details.

    trans =
        transform << calculate "datum.sex == 2 ? 'F' : 'M'" "gender"

-}
calculate : String -> String -> List LabelledSpec -> List LabelledSpec
calculate expr label =
    (::) ( "calculate", JE.list [ JE.string expr, JE.string label ] )


{-| Create a set of discrete domain to color mappings suitable for customising categorical
scales. The first item in each tuple should be a domain value and the second the
colour value with which it should be associated. It is a convenience function equivalent
to specifying separate `SDomain` and `SRange` lists and is safer as it guarantees
a one-to-one correspondence between domain and range values.

    color
        [ MName "weather"
        , MmType Nominal
        , MScale <|
            categoricalDomainMap
                [ ( "sun", "yellow" )
                , ( "rain", "blue" )
                , ( "fog", "grey" )
                ]
        ]

-}
categoricalDomainMap : List ( String, String ) -> List ScaleProperty
categoricalDomainMap scaleDomainPairs =
    let
        ( domain, range ) =
            List.unzip scaleDomainPairs
    in
    [ SDomain (DStrings domain), SRange (RStrings range) ]


{-| Encode a colour channel. The first parameter is a list of mark channel properties
that characterise the way a data field is encoded by colour. The second parameter
is a list of any previous channels to which this colour channel should be added.

    color [ MName "Species", MmType Nominal ] []

-}
color : List MarkChannel -> List LabelledSpec -> List LabelledSpec
color markProps =
    (::) ( "color", List.concatMap markChannelProperty markProps |> JE.object )


{-| Encodes a new facet to be arranged in columns. The first parameter is a list
of properties that define the faceting channel. This should include at least the
name of the data field and its measurement type. The final parameter is a list of
anyprevious channels to which this is to be added. This is usually implicit when
chaining encodings using functional composition

    enc =
        encoding
            << position X [ PName "people", PmType Quantitative ]
            << position Y [ PName "gender", PmType Nominal ]
            << column [ FName "age", FmType Ordinal ]

-}
column : List FacetChannel -> List LabelledSpec -> List LabelledSpec
column fFields =
    (::) ( "column", JE.object (List.map facetChannelProperty fFields) )


{-| Defines a single configuration option to be applied globally across the visualization.
The first parameter identifies the type of configuration, the second a list of previous
configurations to which this one may be added.

    configuration (Axis [ DomainWidth 4 ]) []

-}
configuration : ConfigurationProperty -> List LabelledSpec -> List LabelledSpec
configuration cfg =
    (::) (configProperty cfg)


{-| Create a single global configuration from a list of configuration specifications.
Configurations are applied to all relevant items in the specification. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html) for
more details.

    config =
        configure
            << configuration (Axis [ DomainWidth 1 ])
            << configuration (View [ Stroke (Just "transparent") ])

-}
configure : List LabelledSpec -> ( Property, Spec )
configure configs =
    ( Config, JE.object configs )


{-| Create a column of data. A column has a name and a list of values. The final
parameter is the list of any other columns to which this is added.

    dataColumn "Animals" (Strings [ "Cat", "Dog", "Mouse"]) []

-}
dataColumn : String -> DataValues -> List Column -> List Column
dataColumn colName data =
    case data of
        Numbers col ->
            (::) (List.map (\x -> ( colName, JE.float x )) col)

        Strings col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        DateTimes col ->
            (::) (List.map (\dts -> ( colName, JE.object (List.map dateTimeProperty dts) )) col)

        Booleans col ->
            (::) (List.map (\b -> ( colName, JE.bool b )) col)


{-| Declare a data source from a provided list of column values. Each column contains
values of the same type, but columns each with a different type are permitted.
Columns should all contain the same number of items; if not the dataset will be
truncated to the length of the shortest column. An optional list for field formatting
instructions can be provided in the first parameter or an empty list to use the
default formatting. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format)
for details.
The columns themselves are most easily generated with `dataColumn`

    data =
        dataFromColumns [ Parse [ ( "Year", FDate "%Y" ) ] ]
            << dataColumn "Animals" (Strings [ "Fish", "Dog", "Cat" ])
            << dataColumn "Ages" (Numbers [ 28, 12, 6 ])
            << dataColumn "Year" (Strings [ "2010", "2014", "2015" ])

-}
dataFromColumns : List Format -> List Column -> ( Property, Spec )
dataFromColumns fmts cols =
    let
        dataArray =
            cols
                |> transpose
                |> List.map JE.object
                |> JE.list
    in
    if fmts == [] then
        ( Data, JE.object [ ( "values", dataArray ) ] )
    else
        ( Data, JE.object [ ( "values", dataArray ), ( "format", JE.object (List.concatMap format fmts) ) ] )


{-| Declare data source from a url. The url can be a local path on a web server
or an external http(s) url. Used to create a data ( property, specification ) pair.
An optional list for field formatting instructions can be provided in the first
parameter or an empty list to use the default formatting. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format)
for details.

    ( Data, dataFromUrl "data/population.json" [])

-}
dataFromUrl : String -> List Format -> ( Property, Spec )
dataFromUrl url fmts =
    if fmts == [] then
        ( Data, JE.object [ ( "url", JE.string url ) ] )
    else
        ( Data, JE.object [ ( "url", JE.string url ), ( "format", JE.object (List.concatMap format fmts) ) ] )


{-| Provides an optional description to be associated with the visualization.

    enc = ...
    toVegaLite
        [ description "Population change of key regions since 1900"
        , dataFromUrl "data/population.json"
        , mark Bar []
        , enc
        ]

-}
description : String -> ( Property, Spec )
description s =
    ( Description, JE.string s )


{-| Encode a 'level of detail' channel. This provides a way of grouping by a field
but unlike, say `color`, all groups have the same visual properties. The first
parameter is a list of the field characteristics to be grouped. The second parameter
is a list of any previous channels to which this shape channel should be added. See the
[Vega-Lite documentation])(<https://vega.github.io/vega-lite/docs/encoding.html#detail>)
for details.

    detail [ DName "Species", DmType Nominal ] []

-}
detail : List DetailChannel -> List LabelledSpec -> List LabelledSpec
detail detailProps =
    (::) ( "detail", List.map detailChannelProperty detailProps |> JE.object )


{-| Create a pair of continuous domain to color mappings suitable for customising
ordered scales. The first parameter is a tuple representing the mapping of the lowest
numeric value in the domain to its equivalent color; the second tuple the mapping
of the highest numeric value to color. If the domain contains any values between
these lower and upper bounds they are interpolated according to the scale's interpolation
function. This is a convenience function equivalent to specifying separate `SDomain`
and `SRange` lists and is safer as it guarantees a one-to-one correspondence between
domain and range values.

    color
        [ MName "year"
        , MmType Ordinal
        , MScale <| domainRangeMap ( 1955, "#e6959c" ) ( 2000, "#911a24" )
        ]

-}
domainRangeMap : ( Float, String ) -> ( Float, String ) -> List ScaleProperty
domainRangeMap lowerMap upperMap =
    let
        ( domain, range ) =
            List.unzip [ lowerMap, upperMap ]
    in
    [ SDomain (DNumbers domain), SRange (RStrings range) ]


{-| Create an encoding specification from a list of channel encodings.

    enc =
        encoding
            << position X [ PName "Animals", PmType Ordinal ]
            << position Y [ PName "Ages", PmType Quantitative ]
            << shape [ MName "Species", MmType Nominal ]
            << size [ MName "Population", MmType Quantitative ]

-}
encoding : List LabelledSpec -> ( Property, Spec )
encoding channels =
    ( Encoding, JE.object channels )


{-| Defines the fields that will be used to facet a view in rows or columns to create
a set of small multiples. This is used where the encoding of the visualization in small
multiples is identical, but data for each is grouped by the given fields. When
creating a faceted view in this way you also need to define a full specification
to apply to each of those facets using `asSpec`.

    spec = ...
    toVegaLite
        [ facet [ RowBy [ FName "Origin", FmType Nominal ] ]
        , specifcation spec
        ]

See the [Vega-Lite documentation](https://vega.github.io/vega-lite/docs/facet.html)
for further details.

-}
facet : List FacetMapping -> ( Property, Spec )
facet fMaps =
    ( Facet, JE.object (List.map facetMappingProperty fMaps) )


{-| Adds the given filter operation a list of transformations that may be applied
to a channel or field. The first parameter is the filter operation and the second,
often implicit, parameter is the list of other filter operations to which this
should be added in sequence.

    trans =
        transform
            << filter (FEqual "Animal" (Str "Cat"))

-}
filter : Filter -> List LabelledSpec -> List LabelledSpec
filter f =
    case f of
        FExpr expr ->
            (::) ( "filter", JE.string expr )

        FEqual field val ->
            (::) ( "filter", JE.object [ ( "field", JE.string field ), ( "equal", datavalue val ) ] )

        FSelection selName ->
            (::) ( "filter", JE.object [ ( "selection", JE.string selName ) ] )

        FRange field vals ->
            let
                values =
                    case vals of
                        Numbers xs ->
                            List.map JE.float xs |> JE.list

                        DateTimes dts ->
                            List.map (\dt -> JE.object (List.map dateTimeProperty dt)) dts |> JE.list

                        Strings ss ->
                            let
                                _ =
                                    Debug.log "Cannot filter with range of strings " vals
                            in
                            JE.null

                        Booleans bs ->
                            let
                                _ =
                                    Debug.log "Cannot filter with range of Booleans " vals
                            in
                            JE.null
            in
            (::) ( "filter", JE.object [ ( "field", JE.string field ), ( "range", values ) ] )

        FOneOf field vals ->
            let
                values =
                    case vals of
                        Numbers xs ->
                            List.map JE.float xs |> JE.list

                        DateTimes dts ->
                            List.map (\dt -> JE.object (List.map dateTimeProperty dt)) dts |> JE.list

                        Strings ss ->
                            List.map JE.string ss |> JE.list

                        Booleans bs ->
                            List.map JE.bool bs |> JE.list
            in
            (::) ( "filter", JE.object [ ( "field", JE.string field ), ( "oneOf", values ) ] )


{-| Assigns a list of specifications to be juxtaposed horizontally in a visualization.

    let
        spec1 = ...
        spec2 = ...
    in
    toVegaLite
        [ dataFromUrl "data/driving.json"
        , hConcat [ spec1, spec2 ]
        ]

-}
hConcat : List Spec -> ( Property, Spec )
hConcat specs =
    ( HConcat, JE.list specs )


{-| Overrides the default height of the visualization. If not specified the height
will be calculated based on the content of the visualization.

    enc = ...
    toVegaLite
        [ height 300
        , dataFromUrl "data/population.json"
        , mark Bar []
        , enc
        ]

-}
height : Float -> ( Property, Spec )
height h =
    ( Height, JE.float h )


{-| Assigns a list of specifications to superposed layers in a visualization.

    let
        spec1 = ...
        spec2 = ...
    in
    toVegaLite
        [ dataFromUrl "data/driving.json"
        , layer [ spec1, spec2 ]
        ]

-}
layer : List Spec -> ( Property, Spec )
layer specs =
    ( Layer, JE.list specs )


{-| Create a mark specification. Used to create a mark ( property, specification )
pair. All marks must have a type (first parameter) and can optionally be customised
with a list of mark properties such as interpolation style for lines. To keep the
default style for the mark, just provide an empty list for the second parameter.

    mark Circle []
    mark Line [ MInterpolate StepAfter ]

-}
mark : Mark -> List MarkProperty -> ( Property, Spec )
mark mark mProps =
    case mProps of
        [] ->
            ( Mark, JE.string (markLabel mark) )

        _ ->
            ( Mark
            , ( "type", JE.string (markLabel mark) )
                :: List.map markProperty mProps
                |> JE.object
            )


{-| Provides an optional name to be associated with the visualization.

    enc = ...
    toVegaLite
        [ name "PopGrowth"
        , dataFromUrl "data/population.json" []
        , mark Bar []
        , enc
        ]

-}
name : String -> ( Property, Spec )
name s =
    ( Name, JE.string s )


{-| Encode an opacity channel. The first parameter is a list of mark channel properties
that characterise the way a data field is encoded by opacity. The second parameter
is a list of any previous channels to which this shape channel should be added.

    opacity [ MName "Age", MmType Quantitative ] []

-}
opacity : List MarkChannel -> List LabelledSpec -> List LabelledSpec
opacity markProps =
    (::) ( "opacity", List.concatMap markChannelProperty markProps |> JE.object )


{-| Create a named aggregation operation on a field that can be added to a transformation.
The first parameter is the aggregation operation to use; the second the name of
the field in which to apply it and the third the name to be given to this transformation.
For further details see the
[Vega-Lite documentation] (<https://vega.github.io/vega-lite/docs/aggregate.html#aggregate-op-def>).

    trans =
        transform
            << aggregate
                [ opAs Min "people" "lowerBound"
                , opAs Max "people" "upperBound"
                ]
                [ "age" ]

-}
opAs : Operation -> String -> String -> Spec
opAs op field label =
    JE.object [ ( "op", JE.string (opLabel op) ), ( "field", JE.string field ), ( "as", JE.string label ) ]


{-| Encode an order channel. The first parameter is a list of order field definitions
to define the channel. The second parameter is a list of any previous channels to
which this order channel is to be added.

    enc =
        encoding
            << position X [ PName "miles", PmType Quantitative ]
            << position Y [ PName "gas", PmType Quantitative ]
            << order [ OName "year", OmType Temporal ]

-}
order : List OrderChannel -> List LabelledSpec -> List LabelledSpec
order oDefs =
    (::) ( "order", List.map orderChannelProperty oDefs |> JE.object )


{-| Encode a position channel. The first parameter identifies the channel,
the second a list of qualifying options. Usually these will include at least the
name of the data field associated with it and its measurement type (either the field
name directly, or a reference to a row / column repeat field). The final parameter
is a list of any previous channels to which this position channel should be added.
This is often implicit when chaining a series of encodings using functional composition.

      enc =
          encoding
            << position X [ PName "Animals", PmTyoe Ordinal ]

-}
position : Position -> List PositionChannel -> List LabelledSpec -> List LabelledSpec
position pos pDefs =
    (::) ( positionLabel pos, List.map positionChannelProperty pDefs |> JE.object )


{-| Define the fields that will be used to compose rows and columns of a set of
small multiples. This is used where the encoding of the visualization in small
multiples is largely identical, but the data field used in each might vary. When
a list of fields is identified with `repeat` you also need to define a full specification
to apply to each of those fields using `asSpec`.

    spec = ...
    toVegaLite
        [ repeat [ ColumnFields [ "Cat", "Dog", "Fish" ] ]
        , ( Spec, asSpec spec )
        ]

See the [Vega-Lite documentation](https://vega.github.io/vega-lite/docs/repeat.html)
for further details.

-}
repeat : List RepeatFields -> ( Property, Spec )
repeat fields =
    ( Repeat, JE.object (List.map repeatFields fields) )


{-| Define a single resolution option to be applied when scales, axes or legends
in composite views share channel encodings. This allows, for example, two different
colour encodings to be created in a layered view, which otherwise by default would
share colour channels between layers. Each resolution rule should be in a tuple
pairing the channel to which it applies and the rule type.
The first parameter identifies the type of resolution, the second a list of previous
resolutions to which this one may be added.

    resolve
        << resolution (RScale [ ( ChY, Independent ) ])

-}
resolution : Resolve -> List LabelledSpec -> List LabelledSpec
resolution res =
    (::) (resolveProperty res)


{-| Determine whether scales, axes or legends in composite views should share channel
encodings. This allows, for example, two different colour encodings to be created
in a layered view, which otherwise by default would share colour channels between
layers. Each resolution rule should be in a tuple pairing the channel to which it
applies and the rule type.

    let
        res =
            resolve
                << resolution (RLegend [ ( ChColor, Independent ) ])
    in
    toVegaLite
        [ dataFromUrl "data/movies.json" []
        , vConcat [ heatSpec, barSpec ]
        , res []
        ]

For more information see the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/resolve.html).

-}
resolve : List LabelledSpec -> ( Property, Spec )
resolve res =
    ( Resolve, JE.object res )


{-| Encode a new facet to be arranged in rows. The first parameter is a list of
facet properties that define the faceting channel. This should include at least
the name of data the field and its measurement type. The final parameter is a list
of any previous channels to which this is to be added. This is usually implicit
when chaining encodings using functional composition

    enc =
        encoding
            << position X [ PName "people", PmType Quantitative ]
            << position Y [ PName "gender", PmType Nominal ]
            << row [ FName "age", FmType Ordinal ]

-}
row : List FacetChannel -> List LabelledSpec -> List LabelledSpec
row fFields =
    (::) ( "row", JE.object (List.map facetChannelProperty fFields) )


{-| Create a single named selection that may be applied to a data query or transformation.
The first two parameters specify the name to be given to the selection for later reference
and the type of selection made. The third allows additional selection options to
be specified. The fourth is a list of selections to which this is added, which is
commonly implicit when chaining a series of selections together with functional
composition.

    sel =
        selection
            << select "view" Interval [ Bind Scales ] []
            << select "myBrush" Interval []
            << select "myPaintbrush" Multi [ On "mouseover", Nearest True ]

-}
select : String -> Selection -> List SelectionProperty -> List LabelledSpec -> List LabelledSpec
select name sType options =
    let
        selProps =
            ( "type", JE.string (selectionLabel sType) )
                :: List.map selectionProperty options
    in
    (::) ( name, JE.object selProps )


{-| Create a full selection specification from a list of selections. For details
see the [Vega-Lite documentation](https://vega.github.io/vega-lite/docs/selection.html).

    selection =
        selection << select "view" Interval [ Bind Scales ]

-}
selection : List LabelledSpec -> ( Property, Spec )
selection sels =
    ( Selection, JE.object sels )


{-| Encode a shape channel. The first parameter is a list of mark channel properties
that characterise the way a data field is encoded by shape. The second parameter
is a list of any previous channels to which this shape channel should be added.

    shape [ MName "Species", MmType Nominal ] []

-}
shape : List MarkChannel -> List LabelledSpec -> List LabelledSpec
shape markProps =
    (::) ( "shape", List.concatMap markChannelProperty markProps |> JE.object )


{-| Encode a size channel. The first parameter is a list of mark channel properties
that characterise the way a data field is encoded by size. The second parameter
is a list of any previous channels to which this size channel should be added.

    size [ MName "Age", MmType Quantitative ] []

-}
size : List MarkChannel -> List LabelledSpec -> List LabelledSpec
size markProps =
    (::) ( "size", List.concatMap markChannelProperty markProps |> JE.object )


{-| Defines a specification object for use with faceted and repeated small multiples.

    spec = ...
    toVegaLite
        [ facet [ RowBy [ FName "Origin", FmType Nominal ] ]
        , specifcation spec
        ]

-}
specification : Spec -> ( Property, Spec )
specification spec =
    ( Spec, spec )


{-| Encode a text channel. The first parameter is a list of text channel properties
that define the channel. The second parameter is a list of any previous channels to
which this channel is to be added. This is usually implicit when chaining a
set of encodings together with functional composition. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#text)
for further details.

    enc =
        encoding
            << position X [ PName "miles", PmType Quantitative ]
            << position Y [ PName "gas", PmType Quantitative ]
            << text [ TName "miles", TmType Quantitative ]

-}
text : List TextChannel -> List LabelledSpec -> List LabelledSpec
text tDefs =
    (::) ( "text", List.map textChannelProperty tDefs |> JE.object )


{-| Provide an optional title to be displayed in the visualization.

    enc = ...
    toVegaLite
        [ title "Population Growth"
        , dataFromUrl "data/population.json"
        , mark Bar []
        , enc []
        ]

-}
title : String -> ( Property, Spec )
title s =
    ( Title, JE.string s )


{-| Convert a list of Vega-Lite specifications into a single JSON object that may be
passed to Vega-Lite for graphics generation. Commonly these will include at least
a data, mark and encoding specification.

While simple properties like `mark` may be provided directly, it is usually clearer
to label more complex ones such as encodings as separate expressions. This becomes
increasingly helpful for visualizations that involve composition of layers, repeats
and facets.

Specifications can be built up by chaining a series of functions (such as `dataColumn`
or `position` in the example below). Functional composition using the `<<` operator
allows This to be done compactly.

    let
        data =
            dataFromColumns []
                << dataColumn "a" (Strings [ "C", "C", "D", "D", "E", "E" ])
                << dataColumn "b" (Numbers [ 2, 7, 1, 2, 6, 8 ])

        enc =
            encoding
                << position X [ PName "a", PmType Nominal ]
                << position Y [ PName "b", PmType Quantitative, PAggregate Mean ]
    in
    toVegaLite [ data [], enc [], mark Bar [] ]

-}
toVegaLite : List ( Property, Spec ) -> Spec
toVegaLite spec =
    ( "$schema", JE.string "https://vega.github.io/schema/vega-lite/v2.json" )
        :: List.map (\( s, v ) -> ( propertyLabel s, v )) spec
        |> JE.object


{-| Create a single transform from a list of transformation specifications. Note
that the order of transformations can be important, especially if labels created
with `calculate` are used in other transformations. Using the functional composition
pipeline idiom (as example below) allows you to provide the transformations in the
order intended.

    trans =
        transform
            << filter (FExpr "datum.year == 2010")
            << calculate "datum.sex == 2 ? 'Female' : 'Male'" "gender"

-}
transform : List LabelledSpec -> ( Property, Spec )
transform transforms =
    let
        assemble : LabelledSpec -> Spec
        assemble ( str, val ) =
            case str of
                "calculate" ->
                    case JD.decodeString (JD.list JD.value) (JE.encode 0 val) of
                        Ok [ expr, label ] ->
                            JE.object [ ( "calculate", expr ), ( "as", label ) ]

                        _ ->
                            JE.null

                "aggregate" ->
                    case JD.decodeString (JD.list JD.value) (JE.encode 0 val) of
                        Ok [ ops, groups ] ->
                            JE.object [ ( "aggregate", ops ), ( "groupby", groups ) ]

                        _ ->
                            JE.null

                _ ->
                    JE.object [ ( str, val ) ]
    in
    if List.isEmpty transforms then
        ( Transform, JE.null )
    else
        ( Transform, JE.list (List.map assemble transforms) )


{-| Assigns a list of specifications to be juxtaposed vertically in a visualization.

    let
        spec1 = ...
        spec2 = ...
    in
    toVegaLite
        [ dataFromUrl "data/driving.json"
        , vConcat [ spec1, spec2 ]
        ]

-}
vConcat : List Spec -> ( Property, Spec )
vConcat specs =
    ( VConcat, JE.list specs )


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    enc = ...
    toVegaLite
        [ width 500
        , dataFromUrl "data/population.json"
        , mark Bar []
        , enc
        ]

-}
width : Float -> ( Property, Spec )
width w =
    ( Width, JE.float w )



-- ################################################# Private types and functions


type alias LabelledSpec =
    ( String, Spec )


type alias Column =
    List LabelledSpec


transpose : List (List a) -> List (List a)
transpose ll =
    case ll of
        [] ->
            []

        [] :: xss ->
            transpose xss

        (x :: xs) :: xss ->
            let
                heads =
                    List.filterMap List.head xss

                tails =
                    List.filterMap List.tail xss
            in
            (x :: heads) :: transpose (xs :: tails)



-- Functions to convert types into their string label or JS value


anchorLabel : APosition -> String
anchorLabel an =
    case an of
        AStart ->
            "start"

        AMiddle ->
            "middle"

        AEnd ->
            "end"


arrangementLabel : Arrangement -> String
arrangementLabel arrng =
    case arrng of
        Row ->
            "row"

        Column ->
            "column"


autosizeConfig : AutosizeConfig -> LabelledSpec
autosizeConfig asCfg =
    case asCfg of
        APad ->
            ( "type", JE.string "pad" )

        AFit ->
            ( "type", JE.string "fit" )

        ANone ->
            ( "type", JE.string "none" )

        AResize b ->
            ( "resize", JE.bool b )

        AContent ->
            ( "contains", JE.string "content" )

        APadding ->
            ( "contains", JE.string "padding" )


axisConfig : AxisConfig -> LabelledSpec
axisConfig axisCfg =
    case axisCfg of
        BandPosition x ->
            ( "bandPosition", JE.float x )

        DomainColor c ->
            ( "domainColor", JE.string c )

        DomainWidth w ->
            ( "domainWidth", JE.float w )

        GridColor c ->
            ( "gridColor", JE.string c )

        GridDash ds ->
            ( "gridDash", JE.list (List.map JE.float ds) )

        GridOpacity o ->
            ( "gridOpacity", JE.float o )

        GridWidth x ->
            ( "gridWidth", JE.float x )

        LabelColor c ->
            ( "labelColor", JE.string c )

        LabelFont f ->
            ( "labelFont", JE.string f )

        LabelFontSize x ->
            ( "labelFontSize", JE.float x )

        LabelLimit x ->
            ( "labelLimit", JE.float x )

        ShortTimeLabels b ->
            ( "shortTimeLabels", JE.bool b )

        TickColor c ->
            ( "tickColor", JE.string c )

        TickRound b ->
            ( "tickRound", JE.bool b )

        TickWidth x ->
            ( "tickWidth", JE.float x )

        TitleBaseline va ->
            ( "titleBaseline", JE.string (vAlignLabel va) )

        TitleColor c ->
            ( "titleColor", JE.string c )

        TitleFont f ->
            ( "titleFont", JE.string f )

        TitleFontWeight w ->
            ( "titleFontWeight", fontWeight w )

        TitleFontSize x ->
            ( "titleFontSize", JE.float x )

        TitleLimit x ->
            ( "titleLimit", JE.float x )

        TitleX x ->
            ( "titleX", JE.float x )

        TitleY y ->
            ( "titleY", JE.float y )


axisProperty : AxisProperty -> LabelledSpec
axisProperty axisProp =
    case axisProp of
        Format fmt ->
            ( "format", JE.string fmt )

        Labels b ->
            ( "labels", JE.bool b )

        LabelAngle angle ->
            ( "labelAngle", JE.float angle )

        LabelOverlap strat ->
            ( "labelOverlap", JE.string (overlapStrategyLabel strat) )

        LabelPadding pad ->
            ( "labelPadding", JE.float pad )

        Domain b ->
            ( "domain", JE.bool b )

        Grid b ->
            ( "grid", JE.bool b )

        MaxExtent n ->
            ( "maxExtent", JE.float n )

        MinExtent n ->
            ( "minExtent", JE.float n )

        Orient side ->
            ( "orient", JE.string (sideLabel side) )

        Offset n ->
            ( "offset", JE.float n )

        Position n ->
            ( "position", JE.float n )

        ZIndex n ->
            ( "zindex", JE.int n )

        Ticks b ->
            ( "ticks", JE.bool b )

        TickCount n ->
            ( "tickCount", JE.int n )

        TickSize sz ->
            ( "tickSize", JE.float sz )

        Values vals ->
            -- TODO: Convert data values
            ( "values", JE.list (List.map JE.float vals) )

        AxTitle title ->
            ( "title", JE.string title )

        AxTitleAlign align ->
            ( "titleAlign", JE.string (hAlignLabel align) )

        AxTitleAngle angle ->
            ( "titleAngle", JE.float angle )

        AxTitleMaxLength len ->
            ( "titleMaxLength", JE.float len )

        AxTitlePadding pad ->
            ( "titlePadding", JE.float pad )


binProperty : BinProperty -> LabelledSpec
binProperty binProp =
    case binProp of
        MaxBins n ->
            ( "maxbins", JE.int n )

        Base x ->
            ( "base", JE.float x )

        Step x ->
            ( "step", JE.float x )

        Steps xs ->
            ( "steps", JE.list (List.map JE.float xs) )

        MinStep x ->
            ( "minstep", JE.float x )

        Divide x y ->
            ( "divide", JE.list [ JE.float x, JE.float y ] )

        Extent mn mx ->
            ( "extent", JE.list [ JE.float mn, JE.float mx ] )

        Nice b ->
            ( "nice", JE.bool b )


binding : Binding -> LabelledSpec
binding bnd =
    case bnd of
        -- TODO: Would InputRange, InputCheckbox etc. be better names? Or even IRange, ICheckbox etc. for one-letter consistency?
        InRange label props ->
            ( label, JE.object (( "input", JE.string "range" ) :: List.map inputProperty props) )

        InCheckbox label props ->
            ( label, JE.object (( "input", JE.string "checkbox" ) :: List.map inputProperty props) )

        InRadio label props ->
            ( label, JE.object (( "input", JE.string "radio" ) :: List.map inputProperty props) )

        InSelect label props ->
            ( label, JE.object (( "input", JE.string "select" ) :: List.map inputProperty props) )

        InText label props ->
            ( label, JE.object (( "input", JE.string "text" ) :: List.map inputProperty props) )

        InNumber label props ->
            ( label, JE.object (( "input", JE.string "number" ) :: List.map inputProperty props) )

        InDate label props ->
            ( label, JE.object (( "input", JE.string "date" ) :: List.map inputProperty props) )

        InTime label props ->
            ( label, JE.object (( "input", JE.string "time" ) :: List.map inputProperty props) )

        InMonth label props ->
            ( label, JE.object (( "input", JE.string "month" ) :: List.map inputProperty props) )

        InWeek label props ->
            ( label, JE.object (( "input", JE.string "week" ) :: List.map inputProperty props) )

        InDateTimeLocal label props ->
            ( label, JE.object (( "input", JE.string "datetimelocal" ) :: List.map inputProperty props) )

        InTel label props ->
            ( label, JE.object (( "input", JE.string "tel" ) :: List.map inputProperty props) )

        InColor label props ->
            ( label, JE.object (( "input", JE.string "color" ) :: List.map inputProperty props) )


channelLabel : Channel -> String
channelLabel ch =
    case ch of
        ChX ->
            "x"

        ChY ->
            "y"

        ChX2 ->
            "x2"

        ChY2 ->
            "y2"

        ChColor ->
            "color"

        ChOpacity ->
            "opacity"

        ChShape ->
            "shape"

        ChSize ->
            "size"


configProperty : ConfigurationProperty -> LabelledSpec
configProperty configProp =
    case configProp of
        Autosize cfg ->
            ( "autosize", JE.object [ autosizeConfig cfg ] )

        Background bg ->
            ( "background", JE.string bg )

        CountTitle title ->
            ( "countTitle", JE.string title )

        RemoveInvalid b ->
            if b then
                ( "invalidValues", JE.string "filter" )
            else
                ( "invalidValues", JE.null )

        NumberFormat fmt ->
            ( "numberFormat", JE.string fmt )

        Padding left top right bottom ->
            ( "padding"
            , JE.object
                [ ( "left", JE.float left )
                , ( "top", JE.float top )
                , ( "right", JE.float right )
                , ( "bottom", JE.float bottom )
                ]
            )

        TimeFormat fmt ->
            ( "timeFormat", JE.string fmt )

        Axis acs ->
            ( "axis", JE.object (List.map axisConfig acs) )

        AxisX acs ->
            ( "axisX", JE.object (List.map axisConfig acs) )

        AxisY acs ->
            ( "axisY", JE.object (List.map axisConfig acs) )

        AxisLeft acs ->
            ( "axisLeft", JE.object (List.map axisConfig acs) )

        AxisRight acs ->
            ( "axisRight", JE.object (List.map axisConfig acs) )

        AxisTop acs ->
            ( "axisTop", JE.object (List.map axisConfig acs) )

        AxisBottom acs ->
            ( "axisBottom", JE.object (List.map axisConfig acs) )

        AxisBand acs ->
            ( "axisBand", JE.object (List.map axisConfig acs) )

        Legend lps ->
            ( "legend", JE.object (List.map legendProperty lps) )

        MarkStyle mps ->
            ( "mark", JE.object (List.map markProperty mps) )

        AreaStyle mps ->
            ( "area", JE.object (List.map markProperty mps) )

        BarStyle mps ->
            ( "bar", JE.object (List.map markProperty mps) )

        CircleStyle mps ->
            ( "circle", JE.object (List.map markProperty mps) )

        LineStyle mps ->
            ( "line", JE.object (List.map markProperty mps) )

        PointStyle mps ->
            ( "point", JE.object (List.map markProperty mps) )

        RectStyle mps ->
            ( "rect", JE.object (List.map markProperty mps) )

        RuleStyle mps ->
            ( "rule", JE.object (List.map markProperty mps) )

        SquareStyle mps ->
            ( "square", JE.object (List.map markProperty mps) )

        TextStyle mps ->
            ( "text", JE.object (List.map markProperty mps) )

        TickStyle mps ->
            ( "tick", JE.object (List.map markProperty mps) )

        TitleStyle tcs ->
            ( "title", JE.object (List.map titleConfig tcs) )

        Style mps ->
            ( "style", JE.object (List.map markProperty mps) )

        NamedStyle name mps ->
            ( "style", JE.object [ ( name, JE.object (List.map markProperty mps) ) ] )

        Scale scs ->
            ( "scale", JE.object (List.map scaleConfig scs) )

        Range rcs ->
            ( "range", JE.object (List.map rangeConfig rcs) )

        View vcs ->
            ( "view", JE.object (List.map viewConfig vcs) )


dateTimeProperty : DateTime -> LabelledSpec
dateTimeProperty dt =
    case dt of
        DTYear y ->
            ( "year", JE.int y )

        DTQuarter q ->
            ( "quarter", JE.int q )

        DTMonth mon ->
            ( "month", JE.string (monthLabel mon) )

        DTDate dt ->
            ( "date", JE.int dt )

        DTDay day ->
            ( "day", JE.string (dayLabel day) )

        DTHours h ->
            ( "hours", JE.int h )

        DTMinutes m ->
            ( "minutes", JE.int m )

        DTSeconds s ->
            ( "seconds", JE.int s )

        DTMilliseconds ms ->
            ( "milliseconds", JE.int ms )


datavalue : DataValue -> Spec
datavalue val =
    case val of
        Number x ->
            JE.float x

        Str s ->
            JE.string s

        Boolean b ->
            JE.bool b

        DT dt ->
            JE.object (List.map dateTimeProperty dt)


dayLabel : DayName -> String
dayLabel day =
    case day of
        Mon ->
            "Mon"

        Tue ->
            "Tue"

        Wed ->
            "Wed"

        Thu ->
            "Thu"

        Fri ->
            "Fri"

        Sat ->
            "Sat"

        Sun ->
            "Sun"


detailChannelProperty : DetailChannel -> LabelledSpec
detailChannelProperty field =
    case field of
        DName s ->
            ( "field", JE.string s )

        DmType t ->
            ( "type", JE.string (measurementLabel t) )

        DBin bps ->
            bin bps

        DTimeUnit tu ->
            ( "timeUnit", JE.string (timeUnitLabel tu) )

        DAggregate op ->
            ( "aggregate", JE.string (opLabel op) )



-- eventLabel : Event -> String
-- eventLabel e =
--     case e of
--         Click ->
--             "click"
--
--         DblClick ->
--             "dblclick"
--
--         DragEnter ->
--             "dragenter"
--
--         DragLeave ->
--             "dragleave"
--
--         DragOver ->
--             "dragover"
--
--         KeyDown ->
--             "keydown"
--
--         KeyPress ->
--             "keypress"
--
--         KeyUp ->
--             "keyup"
--
--         MouseDown ->
--             "mousedown"
--
--         MouseMove ->
--             "mousemove"
--
--         MouseOut ->
--             "mouseout"
--
--         MouseOver ->
--             "mouseover"
--
--         MouseUp ->
--             "mouseup"
--
--         MouseWheel ->
--             "mousewheel"
--
--         TouchEnd ->
--             "touchend"
--
--         TouchMove ->
--             "touchmove"
--
--         TouchStart ->
--             "touchstart"
--
--         Wheel ->
--             "touchwheel"


facetChannelProperty : FacetChannel -> LabelledSpec
facetChannelProperty fMap =
    case fMap of
        FName s ->
            ( "field", JE.string s )

        FmType measure ->
            ( "type", JE.string (measurementLabel measure) )

        FBin bps ->
            bin bps

        FAggregate op ->
            ( "aggregate", JE.string (opLabel op) )

        FTimeUnit tu ->
            ( "timeUnit", JE.string (timeUnitLabel tu) )

        FHeader hProps ->
            ( "header", JE.object (List.map headerProperty hProps) )


facetMappingProperty : FacetMapping -> LabelledSpec
facetMappingProperty fMap =
    case fMap of
        RowBy fFields ->
            ( "row", JE.object (List.map facetChannelProperty fFields) )

        ColumnBy fFields ->
            ( "column", JE.object (List.map facetChannelProperty fFields) )


headerProperty : HeaderProperty -> LabelledSpec
headerProperty hProp =
    case hProp of
        HFormat fmt ->
            ( "format", JE.string fmt )

        HTitle title ->
            ( "title", JE.string title )


fontWeight : FontWeight -> Spec
fontWeight w =
    case w of
        Normal ->
            JE.string "normal"

        Bold ->
            JE.string "bold"

        Bolder ->
            JE.string "bolder"

        Lighter ->
            JE.string "lighter"

        W100 ->
            JE.float 100

        W200 ->
            JE.float 200

        W300 ->
            JE.float 300

        W400 ->
            JE.float 400

        W500 ->
            JE.float 500

        W600 ->
            JE.float 600

        W700 ->
            JE.float 700

        W800 ->
            JE.float 800

        W900 ->
            JE.float 900


fDataType : FDataType -> Spec
fDataType dType =
    case dType of
        FNumber ->
            JE.string "number"

        FBoolean ->
            JE.string "boolean"

        FDate dateFmt ->
            if dateFmt == "" then
                JE.string "date"
            else
                JE.string ("date:'" ++ dateFmt ++ "'")

        FUtc dateFmt ->
            if dateFmt == "" then
                JE.string "utc"
            else
                JE.string ("utc:'" ++ dateFmt ++ "'")


format : Format -> List LabelledSpec
format fmt =
    case fmt of
        JSON ->
            [ ( "type", JE.string "json" ) ]

        CSV ->
            [ ( "type", JE.string "csv" ) ]

        TSV ->
            [ ( "type", JE.string "tsv" ) ]

        TopojsonFeature objectSet ->
            [ ( "type", JE.string "json" ), ( "feature", JE.string objectSet ) ]

        TopojsonMesh objectSet ->
            [ ( "type", JE.string "json" ), ( "mesh", JE.string objectSet ) ]

        Parse fmts ->
            [ ( "parse", JE.object <| List.map (\( field, fmt ) -> ( field, fDataType fmt )) fmts ) ]


hAlignLabel : HAlign -> String
hAlignLabel align =
    case align of
        AlignLeft ->
            "left"

        AlignCenter ->
            "center"

        AlignRight ->
            "right"


inputProperty : InputProperty -> LabelledSpec
inputProperty prop =
    case prop of
        InMin x ->
            ( "min", JE.float x )

        InMax x ->
            ( "max", JE.float x )

        InStep x ->
            ( "step", JE.float x )

        Debounce x ->
            ( "debounce", JE.float x )

        InOptions opts ->
            ( "options", JE.list (List.map JE.string opts) )

        InPlaceholder el ->
            ( "placeholder", JE.string el )

        Element el ->
            ( "element", JE.string el )


interpolateProperty : CInterpolate -> Spec
interpolateProperty iType =
    case iType of
        Rgb gamma ->
            JE.object [ ( "type", JE.string "rgb" ), ( "gamma", JE.float gamma ) ]

        Hsl ->
            JE.object [ ( "type", JE.string "hsl" ) ]

        HslLong ->
            JE.object [ ( "type", JE.string "hsl-long" ) ]

        Lab ->
            JE.object [ ( "type", JE.string "lab" ) ]

        Hcl ->
            JE.object [ ( "type", JE.string "hcl" ) ]

        HclLong ->
            JE.object [ ( "type", JE.string "hcl-long" ) ]

        CubeHelix gamma ->
            JE.object [ ( "type", JE.string "cubehelix" ), ( "gamma", JE.float gamma ) ]

        CubeHelixLong gamma ->
            JE.object [ ( "type", JE.string "cubehelix-long" ), ( "gamma", JE.float gamma ) ]


legendOrientLabel : LegendOrientation -> String
legendOrientLabel orient =
    case orient of
        Left ->
            "left"

        BottomLeft ->
            "bottom-left"

        BottomRight ->
            "bottom-right"

        Right ->
            "right"

        TopLeft ->
            "top-left"

        TopRight ->
            "top-right"

        None ->
            "none"


legendProperty : LegendProperty -> LabelledSpec
legendProperty legendProp =
    case legendProp of
        LType lType ->
            case lType of
                Gradient ->
                    ( "type", JE.string "gradient" )

                Symbol ->
                    ( "type", JE.string "symbol" )

        LEntryPadding x ->
            ( "entryPadding", JE.float x )

        LFormat s ->
            ( "format", JE.string s )

        LOffset x ->
            ( "offset", JE.float x )

        LOrient or ->
            ( "orient", JE.string (legendOrientLabel or) )

        LPadding x ->
            ( "padding", JE.float x )

        LTickCount x ->
            ( "tickCount", JE.float x )

        LTitle title ->
            if title == "" then
                ( "title", JE.null )
            else
                ( "title", JE.string title )

        LValues vals ->
            let
                list =
                    case vals of
                        Numbers xs ->
                            List.map JE.float xs |> JE.list

                        DateTimes dts ->
                            List.map (\dt -> JE.object (List.map dateTimeProperty dt)) dts |> JE.list

                        Strings ss ->
                            List.map JE.string ss |> JE.list

                        Booleans bs ->
                            let
                                _ =
                                    Debug.log "Cannot create legend values with a list of Booleans " vals
                            in
                            JE.null
            in
            ( "values", list )

        LZIndex n ->
            ( "zindex", JE.int n )


markChannelProperty : MarkChannel -> List LabelledSpec
markChannelProperty field =
    case field of
        MName s ->
            [ ( "field", JE.string s ) ]

        MRepeat arr ->
            [ ( "field", JE.object [ ( "repeat", JE.string (arrangementLabel arr) ) ] ) ]

        MmType t ->
            [ ( "type", JE.string (measurementLabel t) ) ]

        MScale sps ->
            [ ( "scale", JE.object (List.map scaleProperty sps) ) ]

        MLegend lps ->
            if lps == [] then
                [ ( "legend", JE.null ) ]
            else
                [ ( "legend", JE.object (List.map legendProperty lps) ) ]

        MBin bps ->
            [ bin bps ]

        MCondition selName ifClause elseClause ->
            ( "condition", JE.object (( "selection", JE.string selName ) :: List.concatMap markChannelProperty ifClause) )
                :: List.concatMap markChannelProperty elseClause

        MTimeUnit tu ->
            [ ( "timeUnit", JE.string (timeUnitLabel tu) ) ]

        MAggregate op ->
            [ ( "aggregate", JE.string (opLabel op) ) ]

        MNumber x ->
            [ ( "value", JE.float x ) ]

        MString s ->
            [ ( "value", JE.string s ) ]

        MBoolean b ->
            [ ( "value", JE.bool b ) ]


markInterpolationLabel : MarkInterpolation -> String
markInterpolationLabel interp =
    case interp of
        Linear ->
            "linear"

        LinearClosed ->
            "linear-closed"

        Stepwise ->
            "step"

        StepBefore ->
            "step-before"

        StepAfter ->
            "step-after"

        Basis ->
            "basis"

        BasisOpen ->
            "basis-open"

        BasisClosed ->
            "basis-closed"

        Cardinal ->
            "cardinal"

        CardinalOpen ->
            "cardinal-open"

        CardinalClosed ->
            "cardinal-closed"

        Bundle ->
            "bundle"

        Monotone ->
            "monotone"


markLabel : Mark -> String
markLabel mark =
    case mark of
        Area ->
            "area"

        Bar ->
            "bar"

        Circle ->
            "circle"

        Line ->
            "line"

        Point ->
            "point"

        Rect ->
            "rect"

        Rule ->
            "rule"

        Square ->
            "square"

        Text ->
            "text"

        Tick ->
            "tick"


markOrientLabel : MarkOrientation -> String
markOrientLabel orient =
    case orient of
        Horizontal ->
            "horizontal"

        Vertical ->
            "vertical"


markProperty : MarkProperty -> LabelledSpec
markProperty mProp =
    case mProp of
        MFilled b ->
            ( "filled", JE.bool b )

        MClip b ->
            ( "clip", JE.bool b )

        MColor col ->
            ( "color", JE.string col )

        MFill col ->
            ( "fill", JE.string col )

        MStroke col ->
            ( "stroke", JE.string col )

        MOpacity x ->
            ( "opacity", JE.float x )

        MFillOpacity x ->
            ( "fillOpacity", JE.float x )

        MStrokeOpacity x ->
            ( "strokeOpacity", JE.float x )

        MStrokeWidth x ->
            ( "strokeWidth", JE.float x )

        MStrokeDash xs ->
            ( "strokeDash", JE.list (List.map JE.float xs) )

        MStrokeDashOffset x ->
            ( "strokeDashOffset", JE.float x )

        MStyle styles ->
            ( "style", JE.list (List.map JE.string styles) )

        MInterpolate interp ->
            ( "interpolate", JE.string (markInterpolationLabel interp) )

        MTension x ->
            ( "tension", JE.float x )

        MOrient orient ->
            ( "orient", JE.string (markOrientLabel orient) )

        MShape sym ->
            ( "shape", JE.string (symbolLabel sym) )

        MSize x ->
            ( "size", JE.float x )

        MAngle x ->
            ( "angle", JE.float x )

        MAlign align ->
            ( "align", JE.string (hAlignLabel align) )

        MBaseline va ->
            ( "baseline", JE.string (vAlignLabel va) )

        MdX dx ->
            ( "dx", JE.float dx )

        MdY dy ->
            ( "dy", JE.float dy )

        MFont fnt ->
            ( "font", JE.string fnt )

        MFontSize x ->
            ( "fontSize", JE.float x )

        MFontStyle fSty ->
            ( "fontStyle", JE.string fSty )

        MFontWeight w ->
            ( "fontWeight", fontWeight w )

        MRadius x ->
            ( "radius", JE.float x )

        MText txt ->
            ( "text", JE.string txt )

        MTheta x ->
            ( "theta", JE.float x )

        MBinSpacing x ->
            ( "binSpacing", JE.float x )

        MContinuousBandSize x ->
            ( "continuousBandSize", JE.float x )

        MDiscreteBandSize x ->
            ( "discreteBandSize", JE.float x )

        MShortTimeLabels b ->
            ( "shortTimeLabels", JE.bool b )

        MBandSize x ->
            ( "bandSize", JE.float x )

        MThickness x ->
            ( "thickness", JE.float x )


measurementLabel : Measurement -> String
measurementLabel mType =
    case mType of
        Nominal ->
            "nominal"

        Ordinal ->
            "ordinal"

        Quantitative ->
            "quantitative"

        Temporal ->
            "temporal"


monthLabel : MonthName -> String
monthLabel mon =
    case mon of
        Jan ->
            "Jan"

        Feb ->
            "Feb"

        Mar ->
            "Mar"

        Apr ->
            "Apr"

        May ->
            "May"

        Jun ->
            "Jun"

        Jul ->
            "Jul"

        Aug ->
            "Aug"

        Sep ->
            "Sep"

        Oct ->
            "Oct"

        Nov ->
            "Nov"

        Dec ->
            "Dec"


nice : ScaleNice -> Spec
nice ni =
    case ni of
        NMillisecond ->
            JE.string "millisecond"

        NSecond ->
            JE.string "second"

        NMinute ->
            JE.string "minute"

        NHour ->
            JE.string "hour"

        NDay ->
            JE.string "day"

        NWeek ->
            JE.string "week"

        NMonth ->
            JE.string "month"

        NYear ->
            JE.string "year"

        IsNice b ->
            JE.bool b

        NTickCount n ->
            JE.int n


opLabel : Operation -> String
opLabel op =
    case op of
        Count ->
            "count"

        Valid ->
            "valid"

        Missing ->
            "missing"

        Distinct ->
            "distinct"

        Sum ->
            "sum"

        Mean ->
            "mean"

        Average ->
            "average"

        Variance ->
            "variance"

        VarianceP ->
            "variancep"

        Stdev ->
            "stdev"

        StdevP ->
            "stdevp"

        Stderr ->
            "stderr"

        Median ->
            "median"

        Q1 ->
            "q1"

        Q3 ->
            "q3"

        CI0 ->
            "ci0"

        CI1 ->
            "ci1"

        Min ->
            "min"

        Max ->
            "max"


orderChannelProperty : OrderChannel -> LabelledSpec
orderChannelProperty oDef =
    case oDef of
        OName s ->
            ( "field", JE.string s )

        ORepeat arr ->
            ( "field", JE.object [ ( "repeat", JE.string (arrangementLabel arr) ) ] )

        OmType measure ->
            ( "type", JE.string (measurementLabel measure) )

        OBin bps ->
            bin bps

        OAggregate op ->
            ( "aggregate", JE.string (opLabel op) )

        OTimeUnit tu ->
            ( "timeUnit", JE.string (timeUnitLabel tu) )

        OSort ops ->
            case ops of
                [ Ascending ] ->
                    ( "sort", JE.string "ascending" )

                [ Descending ] ->
                    ( "sort", JE.string "descending" )

                _ ->
                    ( "sort", JE.object (List.map sortProperty ops) )


overlapStrategyLabel : OverlapStrategy -> String
overlapStrategyLabel strat =
    case strat of
        ONone ->
            "false"

        OParity ->
            "parity"

        OGreedy ->
            "greedy"


positionChannelProperty : PositionChannel -> LabelledSpec
positionChannelProperty pDef =
    case pDef of
        PName s ->
            ( "field", JE.string s )

        PmType measure ->
            ( "type", JE.string (measurementLabel measure) )

        PBin bps ->
            bin bps

        PAggregate op ->
            ( "aggregate", JE.string (opLabel op) )

        PTimeUnit tu ->
            ( "timeUnit", JE.string (timeUnitLabel tu) )

        PSort ops ->
            case ops of
                [ Ascending ] ->
                    ( "sort", JE.string "ascending" )

                [ Descending ] ->
                    ( "sort", JE.string "descending" )

                _ ->
                    ( "sort", JE.object (List.map sortProperty ops) )

        PScale sps ->
            ( "scale", JE.object (List.map scaleProperty sps) )

        PAxis aps ->
            if aps == [] then
                ( "axis", JE.null )
            else
                ( "axis", JE.object (List.map axisProperty aps) )

        PStack sp ->
            stackProperty sp

        PRepeat arr ->
            ( "field", JE.object [ ( "repeat", JE.string (arrangementLabel arr) ) ] )


positionLabel : Position -> String
positionLabel pChannel =
    case pChannel of
        X ->
            "x"

        Y ->
            "y"

        X2 ->
            "x2"

        Y2 ->
            "y2"


rangeConfig : RangeConfig -> LabelledSpec
rangeConfig rangeCfg =
    case rangeCfg of
        RCategory name ->
            ( "category", JE.object [ scheme name [] ] )

        RDiverging name ->
            ( "diverging", JE.object [ scheme name [] ] )

        RHeatmap name ->
            ( "heatmap", JE.object [ scheme name [] ] )

        ROrdinal name ->
            ( "ordinal", JE.object [ scheme name [] ] )

        RRamp name ->
            ( "ramp", JE.object [ scheme name [] ] )

        RSymbol name ->
            ( "symbol", JE.object [ scheme name [] ] )


repeatFields : RepeatFields -> LabelledSpec
repeatFields fields =
    case fields of
        RowFields fields ->
            ( "row", JE.list (List.map JE.string fields) )

        ColumnFields fields ->
            ( "column", JE.list (List.map JE.string fields) )


resolveProperty : Resolve -> LabelledSpec
resolveProperty res =
    case res of
        RAxis chRules ->
            --( "axis", JE.object [ ( channelLabel ch, JE.string (resolutionLabel rule) ) ] )
            ( "axis", JE.object <| List.map (\( ch, rule ) -> ( channelLabel ch, JE.string (resolutionLabel rule) )) chRules )

        RLegend chRules ->
            --( "legend", JE.object [ ( channelLabel ch, JE.string (resolutionLabel rule) ) ] )
            ( "legend", JE.object <| List.map (\( ch, rule ) -> ( channelLabel ch, JE.string (resolutionLabel rule) )) chRules )

        RScale chRules ->
            --( "scale", JE.object [ ( channelLabel ch, JE.string (resolutionLabel rule) ) ] )
            ( "scale", JE.object <| List.map (\( ch, rule ) -> ( channelLabel ch, JE.string (resolutionLabel rule) )) chRules )


resolutionLabel : Resolution -> String
resolutionLabel res =
    case res of
        Shared ->
            "shared"

        Independent ->
            "independent"


selectionResolutionLabel : SelectionResolution -> String
selectionResolutionLabel res =
    case res of
        Global ->
            "global"

        Union ->
            "union"

        Intersection ->
            "intersect"


scaleConfig : ScaleConfig -> LabelledSpec
scaleConfig scaleCfg =
    case scaleCfg of
        SCBandPaddingInner x ->
            ( "bandPaddingInner", JE.float x )

        SCBandPaddingOuter x ->
            ( "bandPaddingOuter", JE.float x )

        SCClamp b ->
            ( "clamp", JE.bool b )

        SCMaxBandSize x ->
            ( "maxBandSize", JE.float x )

        SCMinBandSize x ->
            ( "minBandSize", JE.float x )

        SCMaxFontSize x ->
            ( "maxFontSize", JE.float x )

        SCMinFontSize x ->
            ( "minFontSize", JE.float x )

        SCMaxOpacity x ->
            ( "maxOpacity", JE.float x )

        SCMinOpacity x ->
            ( "minOpacity", JE.float x )

        SCMaxSize x ->
            ( "maxSize", JE.float x )

        SCMinSize x ->
            ( "minSize", JE.float x )

        SCMaxStrokeWidth x ->
            ( "maxStrokeWidth", JE.float x )

        SCMinStrokeWidth x ->
            ( "minStrokeWidth", JE.float x )

        SCPointPadding x ->
            ( "pointPadding", JE.float x )

        SCRangeStep numOrNull ->
            case numOrNull of
                Just x ->
                    ( "rangeStep", JE.float x )

                Nothing ->
                    ( "rangeStep", JE.null )

        SCRound b ->
            ( "round", JE.bool b )

        SCTextXRangeStep x ->
            ( "textXRangeStep", JE.float x )

        SCUseUnaggregatedDomain b ->
            ( "useUnaggregatedDomain", JE.bool b )


scaleDomainProperty : ScaleDomain -> Spec
scaleDomainProperty sdType =
    case sdType of
        DNumbers nums ->
            JE.list (List.map JE.float nums)

        DDateTimes dts ->
            List.map (\dt -> JE.object (List.map dateTimeProperty dt)) dts |> JE.list

        DStrings cats ->
            JE.list (List.map JE.string cats)

        DSelection selName ->
            JE.object [ ( "selection", JE.string selName ) ]

        Unaggregated ->
            JE.string "unaggregated"


scaleProperty : ScaleProperty -> LabelledSpec
scaleProperty scaleProp =
    case scaleProp of
        SType sType ->
            ( "type", JE.string (scaleLabel sType) )

        SDomain sdType ->
            ( "domain", scaleDomainProperty sdType )

        SRange range ->
            case range of
                RNumbers xs ->
                    ( "range", JE.list (List.map JE.float xs) )

                RStrings ss ->
                    ( "range", JE.list (List.map JE.string ss) )

                RName s ->
                    ( "range", JE.string s )

        SScheme name extent ->
            scheme name extent

        SPadding x ->
            ( "padding", JE.float x )

        SPaddingInner x ->
            ( "paddingInner", JE.float x )

        SPaddingOuter x ->
            ( "paddingOuter", JE.float x )

        SRangeStep numOrNull ->
            case numOrNull of
                Just x ->
                    ( "rangeStep", JE.float x )

                Nothing ->
                    ( "rangeStep", JE.null )

        SRound b ->
            ( "round", JE.bool b )

        SClamp b ->
            ( "clamp", JE.bool b )

        SInterpolate interp ->
            ( "interpolate", interpolateProperty interp )

        SNice ni ->
            ( "nice", nice ni )

        SZero b ->
            ( "zero", JE.bool b )

        SReverse b ->
            ( "reverse", JE.bool b )


scaleRangeProperty : ScaleRange -> Spec
scaleRangeProperty srType =
    case srType of
        RNumbers nums ->
            JE.list (List.map JE.float nums)

        RStrings cats ->
            JE.list (List.map JE.string cats)

        RName name ->
            JE.string name


scaleLabel : Scale -> String
scaleLabel scType =
    case scType of
        ScLinear ->
            "linear"

        ScPow ->
            "pow"

        ScSqrt ->
            "sqrt"

        ScLog ->
            "log"

        ScTime ->
            "time"

        ScUtc ->
            "utc"

        ScSequential ->
            "sequential"

        ScOrdinal ->
            "ordinal"

        ScBand ->
            "band"

        ScPoint ->
            "point"

        ScBinLinear ->
            "bin-linear"

        ScBinOrdinal ->
            "bin-ordinal"


scheme : String -> List Float -> LabelledSpec
scheme name extent =
    case extent of
        [ mn, mx ] ->
            ( "scheme", JE.object [ ( "name", JE.string name ), ( "extent", JE.list [ JE.float mn, JE.float mx ] ) ] )

        _ ->
            ( "scheme", JE.string name )


selectionLabel : Selection -> String
selectionLabel seType =
    case seType of
        Single ->
            "single"

        Multi ->
            "multi"

        Interval ->
            "interval"


selectionMarkProperty : SelectionMarkProperty -> LabelledSpec
selectionMarkProperty markProp =
    case markProp of
        SMFill colour ->
            ( "fill", JE.string colour )

        SMFillOpacity x ->
            ( "fillOpacity", JE.float x )

        SMStroke colour ->
            ( "stroke", JE.string colour )

        SMStrokeOpacity x ->
            ( "strokeOpacity", JE.float x )

        SMStrokeWidth x ->
            ( "strokeWidth", JE.float x )

        SMStrokeDash xs ->
            ( "strokeDash", JE.list (List.map JE.float xs) )

        SMStrokeDashOffset x ->
            ( "strokeDashOffset", JE.float x )


selectionProperty : SelectionProperty -> LabelledSpec
selectionProperty selProp =
    case selProp of
        -- TODO: Because named fields have to be paired, can we use a tuple instead?
        Fields fNames ->
            ( "fields", JE.list (List.map JE.string fNames) )

        -- TODO: Because channels have to be paired, can we use a tuple instead?
        Encodings channels ->
            ( "encodings", JE.list (List.map (JE.string << channelLabel) channels) )

        On e ->
            ( "on", JE.string e )

        Empty ->
            ( "empty", JE.string "none" )

        ResolveSelections resolution ->
            ( "resolve", JE.string (selectionResolutionLabel resolution) )

        SelectionMark markProps ->
            ( "mark", JE.object (List.map selectionMarkProperty markProps) )

        BindScales ->
            ( "bind", JE.string "scales" )

        Bind binds ->
            ( "bind", JE.object (List.map binding binds) )

        Nearest b ->
            ( "nearest", JE.bool b )

        NoToggle ->
            ( "toggle", JE.bool False )

        Translate e ->
            if e == "" then
                ( "translate", JE.bool False )
            else
                ( "translate", JE.string e )

        Zoom e ->
            if e == "" then
                ( "zoom", JE.bool False )
            else
                ( "zoom", JE.string e )


sideLabel : Side -> String
sideLabel side =
    case side of
        STop ->
            "top"

        SBottom ->
            "bottom"

        SLeft ->
            "left"

        SRight ->
            "right"


sortProperty : SortProperty -> LabelledSpec
sortProperty sp =
    case sp of
        Ascending ->
            ( "order", JE.string "ascending" )

        Descending ->
            ( "order", JE.string "descending" )

        ByField field ->
            ( "field", JE.string field )

        Op op ->
            ( "op", JE.string (opLabel op) )

        ByRepeat arr ->
            ( "field", JE.object [ ( "repeat", JE.string (arrangementLabel arr) ) ] )


symbolLabel : Symbol -> String
symbolLabel sym =
    case sym of
        SymCircle ->
            "circle"

        SymSquare ->
            "square"

        Cross ->
            "cross"

        Diamond ->
            "diamond"

        TriangleUp ->
            "triangle-up"

        TriangleDown ->
            "triangle-down"

        -- TODO: Check we simply provide an SVG path here.
        Path path ->
            path


propertyLabel : Property -> String
propertyLabel spec =
    case spec of
        Name ->
            "name"

        Description ->
            "description"

        Title ->
            "title"

        Width ->
            "width"

        Height ->
            "height"

        Data ->
            "data"

        Mark ->
            "mark"

        Transform ->
            "transform"

        Encoding ->
            "encoding"

        Config ->
            "config"

        Selection ->
            "selection"

        HConcat ->
            "hconcat"

        VConcat ->
            "vconcat"

        Layer ->
            "layer"

        Repeat ->
            "repeat"

        Facet ->
            "facet"

        Spec ->
            "spec"

        Resolve ->
            "resolve"


stackProperty : StackProperty -> LabelledSpec
stackProperty sp =
    case sp of
        StZero ->
            ( "stack", JE.string "zero" )

        StNormalize ->
            ( "stack", JE.string "normalize" )

        StCenter ->
            ( "stack", JE.string "center" )

        NoStack ->
            ( "stack", JE.null )


textChannelProperty : TextChannel -> LabelledSpec
textChannelProperty tDef =
    case tDef of
        TName s ->
            ( "field", JE.string s )

        TRepeat arr ->
            ( "field", JE.object [ ( "repeat", JE.string (arrangementLabel arr) ) ] )

        TmType measure ->
            ( "type", JE.string (measurementLabel measure) )

        TBin bps ->
            bin bps

        TAggregate op ->
            ( "aggregate", JE.string (opLabel op) )

        TTimeUnit tu ->
            ( "timeUnit", JE.string (timeUnitLabel tu) )

        TFormat fmt ->
            ( "format", JE.string fmt )


titleConfig : TitleConfig -> LabelledSpec
titleConfig titleCfg =
    case titleCfg of
        TAnchor an ->
            ( "anchor", JE.string (anchorLabel an) )

        TAngle x ->
            ( "angle", JE.float x )

        TBaseline va ->
            ( "baseline", JE.string (vAlignLabel va) )

        TColor clr ->
            ( "color", JE.string clr )

        TFont fnt ->
            ( "font", JE.string fnt )

        TFontSize x ->
            ( "fontSize", JE.float x )

        TFontWeight w ->
            ( "fontWeight", fontWeight w )

        TLimit x ->
            ( "limit", JE.float x )

        TOffset x ->
            ( "offset", JE.float x )

        TOrient sd ->
            ( "orient", JE.string (sideLabel sd) )


timeUnitLabel : TimeUnit -> String
timeUnitLabel tu =
    case tu of
        Year ->
            "year"

        YearQuarter ->
            "yearquarter"

        YearQuarterMonth ->
            "yearquartermonth"

        YearMonth ->
            "yearmonth"

        YearMonthDate ->
            "yearmonthdate"

        YearMonthDateHours ->
            "yearmonthdatehours"

        YearMonthDateHoursMinutes ->
            "yearmonthdatehoursminutes"

        YearMonthDateHoursMinutesSeconds ->
            "yearmonthdatehoursminutesseconds"

        Quarter ->
            "quarter"

        QuarterMonth ->
            "quartermonth"

        Month ->
            "month"

        MonthDate ->
            "monthdate"

        Date ->
            "date"

        Day ->
            "day"

        Hours ->
            "hours"

        HoursMinutes ->
            "hoursminutes"

        HoursMinutesSeconds ->
            "hoursminutesseconds"

        Minutes ->
            "minutes"

        MinutesSeconds ->
            "minutesseconds"

        Seconds ->
            "seconds"

        SecondsMilliseconds ->
            "secondsmilliseconds"

        Milliseconds ->
            "milliseconds"


vAlignLabel : VAlign -> String
vAlignLabel align =
    case align of
        AlignTop ->
            "top"

        AlignMiddle ->
            "middle"

        AlignBottom ->
            "bottom"


viewConfig : ViewConfig -> LabelledSpec
viewConfig viewCfg =
    case viewCfg of
        VWidth x ->
            ( "width", JE.float x )

        VHeight x ->
            ( "height", JE.float x )

        Clip b ->
            ( "clip", JE.bool b )

        Fill ms ->
            case ms of
                Just s ->
                    ( "fill", JE.string s )

                Nothing ->
                    ( "fill", JE.string "" )

        FillOpacity mx ->
            case mx of
                Just x ->
                    ( "fillOpacity", JE.float x )

                Nothing ->
                    ( "fillOpacity", JE.null )

        Stroke ms ->
            case ms of
                Just s ->
                    ( "stroke", JE.string s )

                Nothing ->
                    ( "stroke", JE.string "" )

        StrokeOpacity mx ->
            case mx of
                Just x ->
                    ( "strokeOpacity", JE.float x )

                Nothing ->
                    ( "strokeOpacity", JE.null )

        StrokeWidth mx ->
            case mx of
                Just x ->
                    ( "strokeWidth", JE.float x )

                Nothing ->
                    ( "strokeWidth", JE.null )

        StrokeDash mxs ->
            case mxs of
                Just xs ->
                    ( "strokeDash", JE.list (List.map JE.float xs) )

                Nothing ->
                    ( "strokeDash", JE.list [] )

        StrokeDashOffset mx ->
            case mx of
                Just x ->
                    ( "strokeDashOffset", JE.float x )

                Nothing ->
                    ( "strokeDashOffset", JE.null )
