module Vega
    exposing
        ( Autosize(..)
        , AxisProperty(..)
        , Bind(..)
        , CInterpolate(..)
        , ColorValue(..)
        , DataColumn
        , DataReference(..)
        , DataType(..)
        , DataValue(..)
        , DataValues(..)
        , EncodingProperty(..)
        , EventHandler(..)
        , Facet(..)
        , FieldValue(..)
        , Format(..)
        , InputProperty(..)
        , Mark(..)
        , MarkProperty(..)
        , Operation(..)
        , OverlapStrategy(..)
        , Padding(..)
        , RangeDefault(..)
        , Scale(..)
        , ScaleDomain(..)
        , ScaleNice(..)
        , ScaleProperty(..)
        , ScaleRange(..)
        , Side(..)
        , SignalProperty(..)
        , SignalReference(..)
        , SortProperty(..)
        , Source(..)
        , Spec
        , TimeUnit(..)
        , TopMarkProperty(..)
        , VProperty
        , Value(..)
        , autosize
        , axes
        , axis
        , dataColumn
        , dataFromColumns
        , height
        , mark
        , marks
        , padding
        , scale
        , scales
        , signal
        , signals
        , toVega
        , width
        )

{-| This module will allow you to create a full Vega specification in Elm. A
specification is stored as a JSON object and contains sufficient declarative detail
to specify the graphical output. While this a 'pure' Elm library, to create the
graphical output you probably want to send a Vega specification generated by
`toVega` via a port to some JavaScript that invokes the Vega runtime.


# Creating A Vega Specification

Future development of this package will allow full Vega specifications to be provided.
Currently, only a very limited set of Vega options detailed below, is provided for
testing purposes only.

@docs toVega
@docs VProperty
@docs Spec


# Creating the Data Specification

Functions and types for declaring the input data to the visualization.

@docs dataFromColumns
@docs dataColumn
@docs DataColumn
@docs DataReference
@docs DataType
@docs Format
@docs SortProperty
@docs Source


## Axes

@docs axes
@docs axis
@docs AxisProperty
@docs Side
@docs OverlapStrategy


## Marks

@docs marks
@docs mark
@docs Mark
@docs TopMarkProperty
@docs MarkProperty
@docs EncodingProperty


## Signals

TODO: Signal docs here. XXX

@docs signals
@docs signal
@docs SignalReference
@docs SignalProperty
@docs Bind
@docs InputProperty
@docs EventHandler


## Scaling

The mapping of data values to their visual expression.

@docs scales
@docs scale
@docs RangeDefault
@docs ScaleProperty
@docs Scale
@docs ScaleDomain
@docs ScaleRange
@docs ScaleNice
@docs CInterpolate


## Aggregation

@docs Operation


# Global Configuration

Configuration options that affect the entire visualization. These are in addition
to the data and transform options described above.

@docs autosize
@docs height
@docs padding
@docs width
@docs Autosize
@docs Padding


# General Data types

In addition to more general data types like integers and strings, the following types
can carry data used in specifications.

@docs DataValue
@docs DataValues
@docs TimeUnit
@docs ColorValue
@docs FieldValue
@docs Value
@docs Facet

-}

import Json.Encode as JE


{-| Indicates the auto-sizing characteristics of the visualization such as amount
of padding, whether it should fill the parent container etc. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/specification/#autosize-types)
-}
type Autosize
    = AContent
    | AFit
    | ANone
    | APad
    | APadding
    | AResize


{-| Indicates the characteristics of a chart axis such as its orientation, labels
and ticks. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/axes)
-}
type AxisProperty
    = AxScale String
    | AxSide Side
    | AxDomain Bool
      --TODO: AxEncode
    | AxFormat String
    | AxGrid Bool
    | AxGridScale String
    | AxLabels Bool
      -- TODO: Check that AxLabelBound and Flush set to True is equivalent to setting to 1
    | AxLabelBound (Maybe Float)
    | AxLabelFlush (Maybe Float)
    | AxLabelFlushOffset Float
    | AxLabelPadding Float
    | AxLabelOverlap OverlapStrategy
    | AxMinExtent Value
    | AxMaxExtent Value
    | AxOffset Value
    | AxPosition Value
    | AxTicks Bool
    | AxTickCount Int
    | AxTickSize Float
    | AxTitle String
    | AxTitlePadding Float
      -- TODO: AxValues should allow numbers, strings and signal references
    | AxValues (List Float)
    | AxZIndex Int


{-| Describes a binding to some HTML input element such as a checkbox or radio button.
For details see the [Vega documentation](https://vega.github.io/vega/docs/signals/#bind).
-}
type Bind
    = IRange (List InputProperty)
    | ICheckbox (List InputProperty)
    | IRadio (List InputProperty)
    | ISelect (List InputProperty)
    | IText (List InputProperty)
    | INumber (List InputProperty)
    | IDate (List InputProperty)
    | ITime (List InputProperty)
    | IMonth (List InputProperty)
    | IWeek (List InputProperty)
    | IDateTimeLocal (List InputProperty)
    | ITel (List InputProperty)
    | IColor (List InputProperty)


{-| Indicates the type of color interpolation to apply, when mapping a data field
onto a color scale. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative).
-}
type CInterpolate
    = CubeHelix Float
    | CubeHelixLong Float
    | Hcl
    | HclLong
    | Hsl
    | HslLong
    | Lab
    | Rgb Float


{-| Defines a custom colour value. Can use a variety of colour spaces such as RGB,
HSL etc. For more details, see the
[Vega documentation](https://vega.github.io/vega/docs/types/#ColorValue)}
-}
type
    ColorValue
    -- TODO: Need to be able to express these values as the result of scale transforms (see https://vega.github.io/vega/docs/types/#ColorValue )
    = RGB Float Float Float
    | HSL Float Float Float
    | LAB Float Float Float
    | HCL Float Float Float


{-| Represents a single column of data. Used when generating inline data with
`dataColumn`.
-}
type alias DataColumn =
    List LabelledSpec


{-| Reference to one or more sources of data such as dataset, field name or collection
of fields. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#dataref)
-}
type DataReference
    = DDataset String
    | DField String
    | DFields (List String)
    | DReferences (List DataReference)
    | DSort (List SortProperty)


{-| Indicates the type of data to be parsed when reading input data. For `FoDate`
and `FoUtc`, the formatting specification can be specified using
[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format) or
left as an empty string if default date formatting is to be applied. Care should
be taken when assuming default parsing of dates though as different browsers can
parse dates differently. Being explicit about the date format is usually safer.
-}
type DataType
    = FoNumber
    | FoBoolean
    | FoDate String
    | FoUtc String


{-| A single data value. This is used when a function can accept values of different
types (e.g. either a number or a string).
-}
type DataValue
    = Boolean Bool
    | Number Float
    | Str String
    | Empty


{-| A list of data values. This is used when a function can accept lists of
different types (e.g. either a list of numbers or a list of strings).
TODO: Check DateTimes only accept strings.
-}
type DataValues
    = Booleans (List Bool)
    | DateTimes (List String)
    | Numbers (List Float)
    | Strings (List String)


{-| Indicates the charactersitcs of an encoding. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks/#encode).
TODO: Need to expand this doc comment.
-}
type EncodingProperty
    = Enter (List MarkProperty)
    | Update (List MarkProperty)
    | Exit (List MarkProperty)
    | Hover (List MarkProperty)
    | Custom String (List MarkProperty)


{-| Specifies an event handler indicating which events to respond to and what to
update or encode as a result. For details see the
[Vega documentation](https://vega.github.io/vega/docs/signals/#handlers).
-}
type
    EventHandler
    -- TODO: Replace EEvents strings with full event stream types.
    = EEvents String
    | EUpdate String
    | EEncode String
    | EForce Bool


{-| Defines a facet directive. For details see the
[Vega documentation](https://vega.github.io/vega/docs/marks/#facet).
-}
type Facet
    = FaName String
    | FaData String
    | FaField String
      --TODO: | FaAggregate
    | FaGroupBy (List String)


{-| Represents a field value. Rather than a simple field name this can be used to
evaluate a signal, group or parent to indirectly reference a field. For details
see the [Vega documentation](https://vega.github.io/vega/docs/types/#FieldValue).
-}
type FieldValue
    = FName String
    | FSignal SignalReference
    | FDatum FieldValue
    | FGroup FieldValue
    | FParent FieldValue


{-| Specifies the type of format a data source uses. For details see the
[Vega documentation](https://vega.github.io/vega/docs/data/#format).
-}
type Format
    = JSON
    | CSV
    | TSV
    | DSV String
    | TopojsonFeature String
    | TopojsonMesh String
    | Parse (List ( String, DataType ))


{-| GUI Input properties. The type of relevant proerty will depend on the type of
input element selected. For example an `InRange` (slider) can have numeric min,
max and step values; InSelect (selector) has a list of selection label options.
For details see the [Vega documentation](https://vega.github.io/vega/docs/signals/#bind).
The `debounce` property, available for all input types allows a delay in input event
handling to be added in order to avoid unnecessary event broadcasting. The `Element`
property is an optional CSS selector indicating the parent element to which the
input element should be added. This allows the option of the input element to be
outside the visualization container.
-}
type InputProperty
    = Debounce Float
    | Element String
    | InOptions (List String)
    | InMin Float
    | InMax Float
    | InName String
    | InStep Float
    | InPlaceholder String


{-| Type of visual mark used to represent data in the visualization. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks/#types).
-}
type Mark
    = Arc
    | Area
    | Image
    | Group
    | Line
    | Path
    | Rect
    | Rule
    | Shape
    | Symbol
    | Text
    | Trail


{-| Indicates an individual property of a mark used when encoding. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks/#encode).
-}
type
    MarkProperty
    -- TODO: Add remaining properties including custom property
    = MX (List Value)
    | MY (List Value)
    | MX2 (List Value)
    | MY2 (List Value)
    | MWidth (List Value)
    | MHeight (List Value)
    | MFill (List Value)
    | MFillOpacity (List Value)
    | MText (List Value)
    | MAlign (List Value)
    | MBaseline (List Value)


{-| Type of aggregation operation. See the
[Vega documentation](https://vega.github.io/vega/docs/transforms/aggregate/#ops)
for more details.
-}
type Operation
    = ArgMax
    | ArgMin
    | Average
    | CI0
    | CI1
    | Count
    | Distinct
    | Max
    | Mean
    | Median
    | Min
    | Missing
    | Q1
    | Q3
    | Stderr
    | Stdev
    | StdevP
    | Sum
    | Valid
    | Variance
    | VarianceP


{-| Type of overlap strategy to be applied when there is not space to show all
items on an axis. See the
[Vega documentation](https://vega.github.io/vega/docs/axes)
for more details.
-}
type OverlapStrategy
    = ONone
    | OParity
    | OGreedy


{-| Represents padding dimensions in pixel units. `PSize` will set the same value
on all four edges of a rectangular container while `PEdges` can be used to specify
different sizes on each edge in order _left_, _top_, _right_, _bottom_.
-}
type Padding
    = PSize Float
    | PEdges Float Float Float Float


{-| Type of scale range. Can be used to set the default type of range to use
in a scale. The value of the default for each type can be set separately via
config settings. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#range-defaults).
-}
type RangeDefault
    = RWidth
    | RHeight
    | RSymbol
    | RCategory
    | RDiverging
    | ROrdinal
    | RRamp
    | RHeatmap


{-| Used to indicate the type of scale transformation to apply. See the
[Vega documentation](https://vega.github.io/vega/docs/scales/#types) for more details.
-}
type Scale
    = ScLinear
    | ScPow
    | ScSqrt
    | ScLog
    | ScTime
    | ScUtc
    | ScSequential
    | ScOrdinal
    | ScBand
    | ScPoint
    | ScQuantile
    | ScQuantize
    | ScBinLinear
    | ScBinOrdinal
    | ScCustom String


{-| Describes the scale domain (type of data in scale). For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#domain).
-}
type ScaleDomain
    = DNumbers (List Float)
    | DStrings (List String)
      -- TODO: Can we have DateTimes as literals?
      -- TODO: Documentation implies array literals can include signal references as elements. How do we add these?
    | DSignal SignalReference
    | DData (List DataReference)


{-| Describes the way a scale can be rounded to 'nice' numbers. For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative).
-}
type ScaleNice
    = NMillisecond
    | NSecond
    | NMinute
    | NHour
    | NDay
    | NWeek
    | NMonth
    | NYear
    | NInterval TimeUnit Int
    | IsNice Bool
    | NTickCount Int


{-| Individual scale property. Scale properties are related, but not identical,
to Vega-Lite's `ScaleProperty` which in Vega are more comprehensive and flexible.
Scale Properties characterise the fundamental data-to-visual transformations applied
by the `scale` function. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#properties)
-}
type ScaleProperty
    = SType Scale
    | SDomain ScaleDomain
    | SDomainMax Float
    | SDomainMin Float
    | SDomainMid Float
      -- TODO: Do we need domainRaw? Why not just use SDomain DNumbers [1,2,3] etc.?
    | SRange ScaleRange
    | SReverse Bool
    | SRound Bool
    | SClamp Bool
    | SInterpolate CInterpolate
    | SPadding Float
    | SNice ScaleNice
    | SZero Bool
    | SExponent Float
    | SBase Float
    | SAlign Float
    | SPaddingInner Float
    | SPaddingOuter Float
    | SRangeStep Float


{-| Describes a scale range of scale output values. For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#range).
-}
type ScaleRange
    = RNumbers (List Float)
    | RStrings (List String)
    | RSignal SignalReference
    | RScheme String (List Float)
    | RData DataReference
    | RStep Float
    | RDefault RangeDefault


{-| Indicates a rectangular side. Can be used to specify an axis position.
[Vega documentation](https://vega.github.io/vega/docs/axes/#orientation)
for more details.
-}
type Side
    = Left
    | Right
    | Top
    | Bottom


{-| Represents a signal name or expression. For details see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Signal).
-}
type SignalReference
    = SName String
    | SExpr String


{-| Individual signal property. For details see the
[Vega documentation](https://vega.github.io/vega/docs/signals).
-}
type SignalProperty
    = SiName String
    | SiBind Bind
    | SiDescription String
    | SiOn (List (List EventHandler))
      -- TODO: SiUpdate Expression
    | SiReact Bool
    | SiValue DataValue


{-| Allow type of sorting to be customised. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#sort).
-}
type SortProperty
    = Ascending
    | Descending
    | Op Operation
    | ByField String


{-| Indicates the data source for a set of marks. For details see the
[Vega documentation](https://vega.github.io/vega/docs/marks/#from).
-}
type Source
    = SData String
    | SFacet (List Facet)


{-| Represents a Vega specification. Specs can be (and usually are) nested.
They can range from a single Boolean value up to the entire Vega specification.
-}
type alias Spec =
    JE.Value


{-| Describes a unit of time. Useful for encoding and transformations. See the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative)
for further details.
-}
type
    -- TODO: Vega-Lite seems to have more time unit options than Vega (e.g. Quarter, Hours etc. - Check spec to see if this is a doc problem or a genuinely restricted set in Vega)
    TimeUnit
    -- TODO: Add UTC prefix option with a utc function (see https://vega.github.io/vega-lite/docs/timeunit.html)
    = Year
    | YearQuarter
    | YearQuarterMonth
    | YearMonth
    | YearMonthDate
    | YearMonthDateHours
    | YearMonthDateHoursMinutes
    | YearMonthDateHoursMinutesSeconds
    | Quarter
    | QuarterMonth
    | Month
    | MonthDate
    | Date
    | Day
    | Hours
    | HoursMinutes
    | HoursMinutesSeconds
    | Minutes
    | MinutesSeconds
    | Seconds
    | SecondsMilliseconds
    | Milliseconds


{-| Indicates the charactersitcs of a mark. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks).
-}
type TopMarkProperty
    = MType Mark
    | MClip Bool
    | MDescription String
    | MEncode (List EncodingProperty)
    | MFrom Source
    | MInteractive Bool
    | MKey String
    | MName String
      -- TODO: MOn (List Trigger)
      -- TODO: MSort Compare
      -- TODO: MTransform (List Transform)
    | MRole String
    | MStyle (List String)


{-| Represents a value such as a number or reference to a value such as a field label
or transformed value. For details, see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Value)
-}
type Value
    = VSignal SignalReference
    | VColor ColorValue
    | VField FieldValue
    | VScale FieldValue
    | VBand Float
    | VExponent Value
    | VMultiply Value
    | VOffset Value
    | VRound Bool
    | VNumber Float
    | VString String
    | VBool Bool
    | VNull
    | VIfElse String (List Value) (List Value)


{-| Top-level Vega properties. These are for testing purposes only prior to full
Vega spec generatation being made available.
-}
type VProperty
    = VName
    | VDescription
    | VBackground
    | VTitle
    | VWidth
    | VAutosize
    | VHeight
    | VPadding
    | VAutoSize
    | VConfig
    | VSignals
    | VData
    | VScales
    | VProjections
    | VAxes
    | VLegends
    | VMarks


{-| Declare the way the view is sized. See the
[Vega documentation](https://vega.github.io/vega/docs/specification/#autosize-types)
for details.

    TODO: XXX

-}
autosize : List Autosize -> ( VProperty, Spec )
autosize aus =
    ( VAutosize, JE.object (List.map autosizeProperty aus) )


{-| Create the axes used to visualize spatial scale mappings.

    TODO: XXX

-}
axes : List Spec -> ( VProperty, Spec )
axes axs =
    ( VAxes, JE.list axs )


{-| Create a single axis used to visualize a spatial scale mapping.

    TODO: XXX

-}
axis : String -> Side -> List AxisProperty -> List Spec -> List Spec
axis scName side aProps =
    (::)
        ((AxScale scName :: AxSide side :: aProps |> List.map axisProperty)
            |> JE.object
        )


{-| Create a column of data. A column has a name and a list of values. The final
parameter is the list of any other columns to which this is added.

    dataColumn "Animal" (Strings [ "Cat", "Dog", "Mouse"]) []

-}
dataColumn : String -> DataValues -> List DataColumn -> List DataColumn
dataColumn colName data =
    case data of
        Numbers col ->
            (::) (List.map (\x -> ( colName, JE.float x )) col)

        Strings col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        DateTimes col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        Booleans col ->
            (::) (List.map (\b -> ( colName, JE.bool b )) col)


{-| Declare a data source from a provided list of column values. Each column contains
values of the same type, but columns each with a different type are permitted.
Columns should all contain the same number of items; if not the dataset will be
truncated to the length of the shortest column. The first parameter should be the
name given to the data table for later reference. An optional list for field
formatting instructions can be provided in the second parameter or an empty list
to use the default formatting. See the
[Vega documentation](https://vega.github.io/vega/docs/data/#format)
for details.
The columns themselves are most easily generated with `dataColumn`

    data =
        dataFromColumns "animals" [ Parse [ ( "Year", FDate "%Y" ) ] ]
            << dataColumn "Animal" (Strings [ "Fish", "Dog", "Cat" ])
            << dataColumn "Age" (Numbers [ 28, 12, 6 ])
            << dataColumn "Year" (Strings [ "2010", "2014", "2015" ])

-}
dataFromColumns : String -> List Format -> List DataColumn -> ( VProperty, Spec )
dataFromColumns name fmts cols =
    let
        dataArray =
            cols
                |> transpose
                |> List.map JE.object
                |> JE.list
    in
    if fmts == [] then
        ( VData
        , JE.object
            [ ( "name", JE.string name )
            , ( "values", dataArray )
            ]
        )
    else
        ( VData
        , JE.object
            [ ( "name", JE.string name )
            , ( "values", dataArray )
            , ( "format", JE.object (List.concatMap formatProperty fmts) )
            ]
        )


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    TODO: XXX

-}
height : Float -> ( VProperty, Spec )
height w =
    ( VHeight, JE.float w )


{-| Create a single mark definition.

    TODO: XXX

-}
mark : Mark -> List TopMarkProperty -> List Spec -> List Spec
mark mark mProps =
    (::)
        ((MType mark :: mProps |> List.map topMarkProperty)
            |> JE.object
        )


{-| Create the marks used in the visualization.

    TODO: XXX

-}
marks : List Spec -> ( VProperty, Spec )
marks axs =
    ( VMarks, JE.list axs )


{-| Set the padding around the visualization in pixel units. The way padding is
interpreted will depend on the `autosize` properties. See the
[Vega documentation](https://vega.github.io/vega/docs/specification/)
for details.

    TODO: XXX

-}
padding : Padding -> ( VProperty, Spec )
padding pad =
    ( VPadding, paddingSpec pad )


{-| Create a single scale used to map data values to visual properties.

    TODO: XXX

-}
scale : String -> List ScaleProperty -> List Spec -> List Spec
scale name sProps =
    (::)
        (( "name", JE.string name )
            :: List.map scaleProperty sProps
            |> JE.object
        )


{-| Create the scales used to map data values to visual properties.

    TODO: XXX

-}
scales : List Spec -> ( VProperty, Spec )
scales scs =
    ( VScales, JE.list scs )


{-| Create the signals used to add dynamism to the visualization.
For further details see the [Vega documentation](https://vega.github.io/vega/docs/signals)

    TODO: XXX

-}
signals : List Spec -> ( VProperty, Spec )
signals sigs =
    ( VSignals, JE.list sigs )


{-| Create a single signal used to add a dynamic component to a visualization.
For further details see the [Vega documentation](https://vega.github.io/vega/docs/signals)

    TODO: XXX

-}
signal : String -> List SignalProperty -> List Spec -> List Spec
signal sigName sProps =
    (::)
        ((SiName sigName :: sProps |> List.map signalProperty)
            |> JE.object
        )


{-| Convert a list of Vega specifications into a single JSON object that may be
passed to Vega for graphics generation.
Currently this is a placeholder only and is not available for use.
-}
toVega : List ( VProperty, Spec ) -> Spec
toVega spec =
    ( "$schema", JE.string "https://vega.github.io/schema/vega/v3.0.json" )
        :: List.map (\( s, v ) -> ( vPropertyLabel s, v )) spec
        |> JE.object


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    TODO: XXX

-}
width : Float -> ( VProperty, Spec )
width w =
    ( VWidth, JE.float w )



-- ################################################# Private types and functions


type alias LabelledSpec =
    ( String, Spec )


autosizeProperty : Autosize -> LabelledSpec
autosizeProperty asCfg =
    case asCfg of
        APad ->
            ( "type", JE.string "pad" )

        AFit ->
            ( "type", JE.string "fit" )

        ANone ->
            ( "type", JE.string "none" )

        AResize ->
            ( "resize", JE.bool True )

        AContent ->
            ( "contains", JE.string "content" )

        APadding ->
            ( "contains", JE.string "padding" )


axisProperty : AxisProperty -> LabelledSpec
axisProperty ap =
    case ap of
        AxScale scName ->
            ( "scale", JE.string scName )

        AxSide axSide ->
            ( "orient", JE.string (sideLabel axSide) )

        AxFormat fmt ->
            ( "format", JE.string fmt )

        AxDomain b ->
            ( "domain", JE.bool b )

        AxGrid b ->
            ( "grid", JE.bool b )

        AxLabels b ->
            ( "labels", JE.bool b )

        AxLabelOverlap strat ->
            ( "labelOverlap", JE.string (overlapStrategyLabel strat) )

        AxLabelPadding pad ->
            ( "labelPadding", JE.float pad )

        AxMaxExtent val ->
            ( "maxExtent", valueSpec val )

        AxMinExtent val ->
            ( "minExtent", valueSpec val )

        AxGridScale scName ->
            ( "gridScale", JE.string scName )

        AxLabelBound numOrNothing ->
            case numOrNothing of
                Nothing ->
                    ( "labelBound", JE.bool False )

                Just x ->
                    ( "labelBound", JE.float x )

        AxLabelFlush numOrNothing ->
            case numOrNothing of
                Nothing ->
                    ( "labelFlush", JE.bool False )

                Just x ->
                    ( "labelFlush", JE.float x )

        AxLabelFlushOffset pad ->
            ( "labelFlushOffset", JE.float pad )

        AxOffset val ->
            ( "offset", valueSpec val )

        AxPosition val ->
            ( "position", valueSpec val )

        AxTicks b ->
            ( "ticks", JE.bool b )

        AxTickCount n ->
            ( "tickCount", JE.int n )

        AxTickSize sz ->
            ( "tickSize", JE.float sz )

        AxTitle title ->
            ( "title", JE.string title )

        AxTitlePadding pad ->
            ( "titlePadding", JE.float pad )

        AxValues vals ->
            ( "values", JE.list (List.map JE.float vals) )

        AxZIndex n ->
            ( "zindex", JE.int n )


bindingProperty : Bind -> LabelledSpec
bindingProperty bnd =
    let
        bSpec iType props =
            ( "bind", JE.object (( "input", JE.string iType ) :: List.map inputProperty props) )
    in
    case bnd of
        IRange props ->
            bSpec "range" props

        ICheckbox props ->
            bSpec "checkbox" props

        IRadio props ->
            bSpec "radio" props

        ISelect props ->
            bSpec "select" props

        IText props ->
            bSpec "text" props

        INumber props ->
            bSpec "number" props

        IDate props ->
            bSpec "date" props

        ITime props ->
            bSpec "time" props

        IMonth props ->
            bSpec "month" props

        IWeek props ->
            bSpec "week" props

        IDateTimeLocal props ->
            bSpec "datetimelocal" props

        ITel props ->
            bSpec "tel" props

        IColor props ->
            bSpec "color" props


colorProperty : ColorValue -> LabelledSpec
colorProperty cVal =
    case cVal of
        RGB r g b ->
            ( "color", JE.object [ ( "r", JE.float r ), ( "g", JE.float g ), ( "b", JE.float b ) ] )

        HSL h s l ->
            ( "color", JE.object [ ( "h", JE.float h ), ( "s", JE.float s ), ( "l", JE.float l ) ] )

        LAB l a b ->
            ( "color", JE.object [ ( "l", JE.float l ), ( "a", JE.float a ), ( "b", JE.float b ) ] )

        HCL h c l ->
            ( "color", JE.object [ ( "h", JE.float h ), ( "c", JE.float c ), ( "l", JE.float l ) ] )


dataRefProperty : DataReference -> LabelledSpec
dataRefProperty dataRef =
    case dataRef of
        DDataset ds ->
            ( "data", JE.string ds )

        DField df ->
            ( "field", JE.string df )

        DFields dfs ->
            ( "fields", JE.list (List.map JE.string dfs) )

        DReferences drs ->
            ( "fields", JE.object (List.map dataRefProperty drs) )

        DSort sps ->
            if sps == [ Ascending ] then
                ( "sort", JE.bool True )
            else
                ( "sort", JE.object (List.map sortProperty sps) )


encodingProperty : EncodingProperty -> LabelledSpec
encodingProperty ep =
    case ep of
        Enter mProps ->
            ( "enter", JE.object (List.map markProperty mProps) )

        Update mProps ->
            ( "update", JE.object (List.map markProperty mProps) )

        Exit mProps ->
            ( "exit", JE.object (List.map markProperty mProps) )

        Hover mProps ->
            ( "hover", JE.object (List.map markProperty mProps) )

        Custom s mProps ->
            ( s, JE.object (List.map markProperty mProps) )


eventHandlerSpec : List EventHandler -> Spec
eventHandlerSpec ehs =
    let
        eventHandler eh =
            case eh of
                EEvents s ->
                    ( "events", JE.string s )

                EUpdate s ->
                    if s == "" then
                        ( "update", JE.string "{}" )
                    else
                        ( "update", JE.string s )

                EEncode s ->
                    ( "encode", JE.string s )

                EForce b ->
                    ( "force", JE.bool b )
    in
    JE.object (List.map eventHandler ehs)


facetProperty : Facet -> LabelledSpec
facetProperty fct =
    case fct of
        FaName s ->
            ( "name", JE.string s )

        FaData s ->
            ( "data", JE.string s )

        FaField s ->
            ( "field", JE.string s )

        FaGroupBy ss ->
            ( "groupby", JE.list (List.map JE.string ss) )


fieldValueSpec : FieldValue -> Spec
fieldValueSpec fVal =
    case fVal of
        FName fName ->
            JE.string fName

        FSignal sig ->
            JE.object [ signalReferenceProperty sig ]

        FDatum fv ->
            JE.object [ ( "datum", fieldValueSpec fv ) ]

        FGroup fv ->
            JE.object [ ( "group", fieldValueSpec fv ) ]

        FParent fv ->
            JE.object [ ( "parent", fieldValueSpec fv ) ]


foDataTypeSpec : DataType -> Spec
foDataTypeSpec dType =
    case dType of
        FoNumber ->
            JE.string "number"

        FoBoolean ->
            JE.string "boolean"

        FoDate dateFmt ->
            if dateFmt == "" then
                JE.string "date"
            else
                JE.string ("date:'" ++ dateFmt ++ "'")

        FoUtc dateFmt ->
            if dateFmt == "" then
                JE.string "utc"
            else
                JE.string ("utc:'" ++ dateFmt ++ "'")


formatProperty : Format -> List LabelledSpec
formatProperty fmt =
    case fmt of
        JSON ->
            [ ( "type", JE.string "json" ) ]

        CSV ->
            [ ( "type", JE.string "csv" ) ]

        TSV ->
            [ ( "type", JE.string "tsv" ) ]

        DSV delim ->
            [ ( "type", JE.string "dsv" ), ( "delimeter", JE.string delim ) ]

        TopojsonFeature objectSet ->
            [ ( "type", JE.string "json" ), ( "feature", JE.string objectSet ) ]

        TopojsonMesh objectSet ->
            [ ( "type", JE.string "json" ), ( "mesh", JE.string objectSet ) ]

        Parse fmts ->
            [ ( "parse", JE.object <| List.map (\( field, fmt ) -> ( field, foDataTypeSpec fmt )) fmts ) ]


interpolateSpec : CInterpolate -> Spec
interpolateSpec iType =
    case iType of
        Rgb gamma ->
            JE.object [ ( "type", JE.string "rgb" ), ( "gamma", JE.float gamma ) ]

        Hsl ->
            JE.object [ ( "type", JE.string "hsl" ) ]

        HslLong ->
            JE.object [ ( "type", JE.string "hsl-long" ) ]

        Lab ->
            JE.object [ ( "type", JE.string "lab" ) ]

        Hcl ->
            JE.object [ ( "type", JE.string "hcl" ) ]

        HclLong ->
            JE.object [ ( "type", JE.string "hcl-long" ) ]

        CubeHelix gamma ->
            JE.object [ ( "type", JE.string "cubehelix" ), ( "gamma", JE.float gamma ) ]

        CubeHelixLong gamma ->
            JE.object [ ( "type", JE.string "cubehelix-long" ), ( "gamma", JE.float gamma ) ]


inputProperty : InputProperty -> LabelledSpec
inputProperty prop =
    case prop of
        InMin x ->
            ( "min", JE.float x )

        InMax x ->
            ( "max", JE.float x )

        InStep x ->
            ( "step", JE.float x )

        Debounce x ->
            ( "debounce", JE.float x )

        InName s ->
            ( "name", JE.string s )

        InOptions opts ->
            ( "options", JE.list (List.map JE.string opts) )

        InPlaceholder el ->
            ( "placeholder", JE.string el )

        Element el ->
            ( "element", JE.string el )


markLabel : Mark -> String
markLabel m =
    case m of
        Arc ->
            "arc"

        Area ->
            "area"

        Image ->
            "image"

        Group ->
            "group"

        Line ->
            "line"

        Path ->
            "path"

        Rect ->
            "rect"

        Rule ->
            "rule"

        Shape ->
            "shape"

        Symbol ->
            "symbol"

        Text ->
            "text"

        Trail ->
            "trail"


markProperty : MarkProperty -> LabelledSpec
markProperty mProp =
    let
        valRef vs =
            case vs of
                [ VIfElse expr ifs elses ] ->
                    JE.list
                        [ JE.object (( "test", JE.string expr ) :: List.map valueProperty ifs)
                        , JE.object (List.map valueProperty elses)
                        ]

                _ ->
                    JE.object (List.map valueProperty vs)
    in
    case mProp of
        MX vals ->
            ( "x", valRef vals )

        MY vals ->
            ( "y", valRef vals )

        MX2 vals ->
            ( "x2", valRef vals )

        MY2 vals ->
            ( "y2", valRef vals )

        MWidth vals ->
            ( "width", valRef vals )

        MHeight vals ->
            ( "height", valRef vals )

        MFill vals ->
            ( "fill", valRef vals )

        MFillOpacity vals ->
            ( "fillOpacity", valRef vals )

        MText vals ->
            ( "text", valRef vals )

        MAlign vals ->
            ( "align", valRef vals )

        MBaseline vals ->
            ( "baseline", valRef vals )


niceSpec : ScaleNice -> Spec
niceSpec ni =
    case ni of
        NMillisecond ->
            JE.string "millisecond"

        NSecond ->
            JE.string "second"

        NMinute ->
            JE.string "minute"

        NHour ->
            JE.string "hour"

        NDay ->
            JE.string "day"

        NWeek ->
            JE.string "week"

        NMonth ->
            JE.string "month"

        NYear ->
            JE.string "year"

        NInterval tu step ->
            JE.object [ ( "interval", JE.string (timeUnitLabel tu) ), ( "step", JE.int step ) ]

        IsNice b ->
            JE.bool b

        NTickCount n ->
            JE.int n


opLabel : Operation -> String
opLabel op =
    case op of
        ArgMax ->
            "argmax"

        ArgMin ->
            "argmin"

        Average ->
            "average"

        Count ->
            "count"

        CI0 ->
            "ci0"

        CI1 ->
            "ci1"

        Distinct ->
            "distinct"

        Max ->
            "max"

        Mean ->
            "mean"

        Median ->
            "median"

        Min ->
            "min"

        Missing ->
            "missing"

        Q1 ->
            "q1"

        Q3 ->
            "q3"

        Stdev ->
            "stdev"

        StdevP ->
            "stdevp"

        Sum ->
            "sum"

        Stderr ->
            "stderr"

        Valid ->
            "valid"

        Variance ->
            "variance"

        VarianceP ->
            "variancep"


overlapStrategyLabel : OverlapStrategy -> String
overlapStrategyLabel strat =
    case strat of
        ONone ->
            "false"

        OParity ->
            "parity"

        OGreedy ->
            "greedy"


paddingSpec : Padding -> Spec
paddingSpec pad =
    case pad of
        PSize p ->
            JE.float p

        PEdges l t r b ->
            JE.object
                [ ( "left", JE.float l )
                , ( "top", JE.float t )
                , ( "right", JE.float r )
                , ( "bottom", JE.float b )
                ]


rangeDefaultLabel : RangeDefault -> String
rangeDefaultLabel rd =
    case rd of
        RWidth ->
            "width"

        RHeight ->
            "height"

        RSymbol ->
            "symbol"

        RCategory ->
            "category"

        RDiverging ->
            "diverging"

        ROrdinal ->
            "ordinal"

        RRamp ->
            "ramp"

        RHeatmap ->
            "heatmap"


scaleDomainSpec : ScaleDomain -> Spec
scaleDomainSpec sdType =
    case sdType of
        DNumbers nums ->
            JE.list (List.map JE.float nums)

        DStrings cats ->
            JE.list (List.map JE.string cats)

        DSignal signal ->
            JE.object [ signalReferenceProperty signal ]

        DData dataRef ->
            JE.object (List.map dataRefProperty dataRef)


scaleLabel : Scale -> String
scaleLabel scType =
    case scType of
        ScLinear ->
            "linear"

        ScPow ->
            "pow"

        ScSqrt ->
            "sqrt"

        ScLog ->
            "log"

        ScTime ->
            "time"

        ScUtc ->
            "utc"

        ScSequential ->
            "sequential"

        ScOrdinal ->
            "ordinal"

        ScBand ->
            "band"

        ScPoint ->
            "point"

        ScBinLinear ->
            "bin-linear"

        ScBinOrdinal ->
            "bin-ordinal"

        ScQuantile ->
            "quantile"

        ScQuantize ->
            "quantize"

        ScCustom s ->
            s


scaleProperty : ScaleProperty -> LabelledSpec
scaleProperty scaleProp =
    case scaleProp of
        SType sType ->
            ( "type", JE.string (scaleLabel sType) )

        SDomain sdType ->
            ( "domain", scaleDomainSpec sdType )

        SDomainMax sdMax ->
            ( "domainMax", JE.float sdMax )

        SDomainMin sdMin ->
            ( "domainMin", JE.float sdMin )

        SDomainMid sdMid ->
            ( "domainMid", JE.float sdMid )

        SRange range ->
            case range of
                RNumbers xs ->
                    ( "range", JE.list (List.map JE.float xs) )

                RStrings ss ->
                    ( "range", JE.list (List.map JE.string ss) )

                RSignal sig ->
                    ( "range", JE.object [ signalReferenceProperty sig ] )

                RScheme name extent ->
                    ( "range", JE.object [ schemeProperty name extent ] )

                RData dRef ->
                    ( "range", JE.object [ dataRefProperty dRef ] )

                RStep step ->
                    ( "range", JE.object [ ( "step", JE.float step ) ] )

                RDefault rd ->
                    ( "range", JE.string (rangeDefaultLabel rd) )

        SPadding x ->
            ( "padding", JE.float x )

        SPaddingInner x ->
            ( "paddingInner", JE.float x )

        SPaddingOuter x ->
            ( "paddingOuter", JE.float x )

        SRangeStep x ->
            ( "rangeStep", JE.float x )

        SRound b ->
            ( "round", JE.bool b )

        SClamp b ->
            ( "clamp", JE.bool b )

        SInterpolate interp ->
            ( "interpolate", interpolateSpec interp )

        SNice ni ->
            ( "nice", niceSpec ni )

        SZero b ->
            ( "zero", JE.bool b )

        SReverse b ->
            ( "reverse", JE.bool b )

        SExponent x ->
            ( "exponent", JE.float x )

        SBase x ->
            ( "base", JE.float x )

        SAlign x ->
            ( "align", JE.float x )


schemeProperty : String -> List Float -> LabelledSpec
schemeProperty name extent =
    case extent of
        [ mn, mx ] ->
            ( "scheme", JE.object [ ( "name", JE.string name ), ( "extent", JE.list [ JE.float mn, JE.float mx ] ) ] )

        _ ->
            ( "scheme", JE.string name )


sideLabel : Side -> String
sideLabel orient =
    case orient of
        Left ->
            "left"

        Bottom ->
            "bottom"

        Right ->
            "right"

        Top ->
            "top"


signalProperty : SignalProperty -> LabelledSpec
signalProperty sigProp =
    case sigProp of
        SiName siName ->
            ( "name", JE.string siName )

        SiBind bind ->
            bindingProperty bind

        SiDescription s ->
            ( "description", JE.string s )

        SiOn ehs ->
            ( "on", JE.list (List.map eventHandlerSpec ehs) )

        SiReact b ->
            ( "react", JE.bool b )

        SiValue v ->
            case v of
                Boolean b ->
                    ( "value", JE.bool b )

                Number x ->
                    ( "value", JE.float x )

                Str s ->
                    ( "value", JE.string s )

                Empty ->
                    ( "value", JE.object [] )


signalReferenceProperty : SignalReference -> LabelledSpec
signalReferenceProperty signal =
    case signal of
        SName sName ->
            ( "signal", JE.string sName )

        SExpr sExpr ->
            -- TODO: Should we check the expression for validity in any way?
            ( "signal", JE.string sExpr )


sortProperty : SortProperty -> LabelledSpec
sortProperty sp =
    case sp of
        Ascending ->
            ( "order", JE.string "ascending" )

        Descending ->
            ( "order", JE.string "descending" )

        ByField field ->
            ( "field", JE.string field )

        Op op ->
            ( "op", JE.string (opLabel op) )


sourceProperty : Source -> LabelledSpec
sourceProperty src =
    case src of
        SData sName ->
            ( "data", JE.string sName )

        SFacet fcts ->
            ( "facet", JE.object (List.map facetProperty fcts) )


timeUnitLabel : TimeUnit -> String
timeUnitLabel tu =
    case tu of
        Year ->
            "year"

        YearQuarter ->
            "yearquarter"

        YearQuarterMonth ->
            "yearquartermonth"

        YearMonth ->
            "yearmonth"

        YearMonthDate ->
            "yearmonthdate"

        YearMonthDateHours ->
            "yearmonthdatehours"

        YearMonthDateHoursMinutes ->
            "yearmonthdatehoursminutes"

        YearMonthDateHoursMinutesSeconds ->
            "yearmonthdatehoursminutesseconds"

        Quarter ->
            "quarter"

        QuarterMonth ->
            "quartermonth"

        Month ->
            "month"

        MonthDate ->
            "monthdate"

        Date ->
            "date"

        Day ->
            "day"

        Hours ->
            "hours"

        HoursMinutes ->
            "hoursminutes"

        HoursMinutesSeconds ->
            "hoursminutesseconds"

        Minutes ->
            "minutes"

        MinutesSeconds ->
            "minutesseconds"

        Seconds ->
            "seconds"

        SecondsMilliseconds ->
            "secondsmilliseconds"

        Milliseconds ->
            "milliseconds"


topMarkProperty : TopMarkProperty -> LabelledSpec
topMarkProperty mProp =
    case mProp of
        MType m ->
            ( "type", JE.string (markLabel m) )

        MClip b ->
            ( "clip", JE.bool b )

        MDescription s ->
            ( "description", JE.string s )

        MEncode eps ->
            ( "encode", JE.object (List.map encodingProperty eps) )

        MFrom src ->
            ( "from", JE.object [ sourceProperty src ] )

        MInteractive b ->
            ( "interactive", JE.bool b )

        MKey s ->
            ( "key", JE.string s )

        MName s ->
            ( "name", JE.string s )

        MRole s ->
            ( "role", JE.string s )

        MStyle ss ->
            ( "style", JE.list (List.map JE.string ss) )


transpose : List (List a) -> List (List a)
transpose ll =
    case ll of
        [] ->
            []

        [] :: xss ->
            transpose xss

        (x :: xs) :: xss ->
            let
                heads =
                    List.filterMap List.head xss

                tails =
                    List.filterMap List.tail xss
            in
            (x :: heads) :: transpose (xs :: tails)


valueProperty : Value -> LabelledSpec
valueProperty val =
    let
        valOrNum val =
            case val of
                VNumber x ->
                    JE.float x

                _ ->
                    valueSpec val
    in
    case val of
        VSignal sig ->
            signalReferenceProperty sig

        VColor cVal ->
            colorProperty cVal

        VField fVal ->
            ( "field", fieldValueSpec fVal )

        VScale fVal ->
            ( "scale", fieldValueSpec fVal )

        VBand x ->
            ( "band", JE.float x )

        VExponent val ->
            ( "exponent", valOrNum val )

        VMultiply val ->
            ( "mult", valOrNum val )

        VOffset val ->
            ( "offset", valOrNum val )

        VRound b ->
            ( "round", JE.bool b )

        VNumber num ->
            ( "value", JE.float num )

        VString str ->
            ( "value", JE.string str )

        VBool b ->
            ( "value", JE.bool b )

        VNull ->
            ( "value", JE.null )

        VIfElse expr ifs elses ->
            ( "productionRule"
            , JE.object
                [ ( "test", JE.string expr )
                , ( "if", JE.object (List.map valueProperty ifs) )
                , ( "else", JE.object (List.map valueProperty elses) )
                ]
            )
                |> Debug.log "Unexpected production rule passed to valueProperty"


valueSpec : Value -> Spec
valueSpec val =
    case val of
        VSignal sig ->
            JE.object [ signalReferenceProperty sig ]

        VColor cVal ->
            JE.object [ colorProperty cVal ]

        VField fName ->
            fieldValueSpec fName

        VScale fName ->
            fieldValueSpec fName

        VBand x ->
            JE.object [ ( "band", JE.float x ) ]

        VExponent val ->
            JE.object [ valueProperty val ]

        VMultiply val ->
            JE.object [ valueProperty val ]

        VOffset val ->
            JE.object [ valueProperty val ]

        VRound b ->
            JE.object [ ( "round", JE.bool b ) ]

        VNumber num ->
            JE.float num

        VString str ->
            JE.string str

        VBool b ->
            JE.bool b

        VNull ->
            JE.null

        VIfElse expr ifs elses ->
            JE.null


vPropertyLabel : VProperty -> String
vPropertyLabel spec =
    case spec of
        VName ->
            "name"

        VDescription ->
            "description"

        VBackground ->
            "background"

        VTitle ->
            "title"

        VWidth ->
            "width"

        VAutosize ->
            "autosize"

        VHeight ->
            "height"

        VPadding ->
            "padding"

        VAutoSize ->
            "autosize"

        VConfig ->
            "config"

        VSignals ->
            "signals"

        VData ->
            "data"

        VScales ->
            "scales"

        VProjections ->
            "projections"

        VAxes ->
            "axes"

        VLegends ->
            "legends"

        VMarks ->
            "marks"
