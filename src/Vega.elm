module Vega
    exposing
        ( Autosize(..)
        , AxisProperty(..)
        , CInterpolate(..)
        , ColorValue(..)
        , DataColumn
        , DataReference(..)
        , DataType(..)
        , DataValues(..)
        , FieldValue(..)
        , Format(..)
        , Operation(..)
        , OverlapStrategy(..)
        , Padding(..)
        , RangeDefault(..)
        , Scale(..)
        , ScaleDomain(..)
        , ScaleNice(..)
        , ScaleProperty(..)
        , ScaleRange(..)
        , Side(..)
        , Signal(..)
        , SortProperty(..)
        , Spec
        , TimeUnit(..)
        , VProperty
        , Value(..)
        , autosize
        , axes
        , axis
        , dataColumn
        , dataFromColumns
        , height
        , padding
        , scale
        , scales
        , toVega
        , width
        )

{-| This module will allow you to create a full Vega specification in Elm. A
specification is stored as a JSON object and contains sufficient declarative detail
to specify the graphical output. While this a 'pure' Elm library, to create the
graphical output you probably want to send a Vega specification generated by
`toVega` via a port to some JavaScript that invokes the Vega runtime.


# Creating A Vega Specification

Future development of this package will allow full Vega specifications to be provided.
Currently, only a very limited set of Vega options detailed below, is provided for
testing purposes only.

@docs toVega
@docs VProperty
@docs Spec


# Creating the Data Specification

Functions and types for declaring the input data to the visualization.

@docs dataFromColumns
@docs dataColumn
@docs DataColumn
@docs DataReference
@docs DataType
@docs Format
@docs SortProperty


## Signals

TODO: Signal docs here. XXX

@docs Signal


## Scaling

The mapping of data values to their visual expression.

@docs scales
@docs scale
@docs RageDefault
@docs ScaleProperty
@docs Scale
@docs categoricalDomainMap
@docs domainRangeMap
@docs ScaleDomain
@docs ScaleRange
@docs ScaleNice
@docs CInterpolate


## Aggregation

@docs Operation


# Global Configuration

Configuration options that affect the entire visualization. These are in addition
to the data and transform options described above.

@docs autosize
@docs height
@docs padding
@docs width
@docs Autosize
@docs Padding


# General Data types

In addition to more general data types like integers and strings, the following types
can carry data used in specifications.

@docs DataValues
@docs TimeUnit

-}

import Json.Encode as JE


{-| Indicates the auto-sizing characteristics of the visualization such as amount
of padding, whether it should fill the parent container etc. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/specification/#autosize-types)
-}
type Autosize
    = AContent
    | AFit
    | ANone
    | APad
    | APadding
    | AResize


{-| Indicates the characteristics of a chart axis such as its orientation, labels
and ticks. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/axes)
-}
type AxisProperty
    = AxScale String
    | AxSide Side
    | AxDomain Bool
      --TODO: AxEncode
    | AxFormat String
    | AxGrid Bool
    | AxGridScale String
    | AxLabels Bool
      -- TODO: Check that AxLabelBound and Flush set to True is equivalent to setting to 1
    | AxLabelBound (Maybe Float)
    | AxLabelFlush (Maybe Float)
    | AxLabelFlushOffset Float
    | AxLabelPadding Float
    | AxLabelOverlap OverlapStrategy
    | AxMinExtent Value
    | AxMaxExtent Value
    | AxOffset Value
    | AxPosition Value
    | AxTicks Bool
    | AxTickCount Int
    | AxTickSize Float
    | AxTitle String
    | AxTitlePadding Float
      -- TODO: AxValues should allow numbers, strings and signal references
    | AxValues (List Float)
    | AxZIndex Int


{-| Indicates the type of color interpolation to apply, when mapping a data field
onto a color scale. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative).
-}
type CInterpolate
    = CubeHelix Float
    | CubeHelixLong Float
    | Hcl
    | HclLong
    | Hsl
    | HslLong
    | Lab
    | Rgb Float


{-| Defines a custom colour value. Can use a variety of colour spaces such as RGB,
HSL etc. For more details, see the
[Vega documentation](https://vega.github.io/vega/docs/types/#ColorValue)}
-}
type
    ColorValue
    -- TODO: Need to be able to express these values as the result of scale transforms (see https://vega.github.io/vega/docs/types/#ColorValue )
    = RGB Float Float Float
    | HSL Float Float Float
    | LAB Float Float Float
    | HCL Float Float Float


{-| Represents a single column of data. Used when generating inline data with
`dataColumn`.
-}
type alias DataColumn =
    List LabelledSpec


{-| Reference to one or more sources of data such as dataset, field name or collection
of fields. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#dataref)
-}
type DataReference
    = DDataset String
    | DField String
    | DFields (List String)
    | DReferences (List DataReference)
    | DSort (List SortProperty)


{-| Indicates the type of data to be parsed when reading input data. For `FoDate`
and `FoUtc`, the formatting specification can be specified using
[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format) or
left as an empty string if default date formatting is to be applied. Care should
be taken when assuming default parsing of dates though as different browsers can
parse dates differently. Being explicit about the date format is usually safer.
-}
type DataType
    = FoNumber
    | FoBoolean
    | FoDate String
    | FoUtc String


{-| A list of data values. This is used when a function can accept lists of
different types (e.g. either a list of numbers or a list of strings).
TODO: Check DateTimes only accept strings.
-}
type DataValues
    = Booleans (List Bool)
    | DateTimes (List String)
    | Numbers (List Float)
    | Strings (List String)


{-| Represents a field value. Rather than a simple field name this can be used to
evaluate a signal, group or parent to indirectly reference a field. For details
see the [Vega documentation](https://vega.github.io/vega/docs/types/#FieldValue).
-}
type FieldValue
    = FName String
    | FSignal Signal
    | FDatum FieldValue
    | FGroup FieldValue
    | FParent FieldValue


{-| Specifies the type of format a data source uses. For details see the
[Vega documentation](https://vega.github.io/vega/docs/data/#format).
-}
type Format
    = JSON
    | CSV
    | TSV
    | DSV String
    | TopojsonFeature String
    | TopojsonMesh String
    | Parse (List ( String, DataType ))


{-| Type of aggregation operation. See the
[Vega documentation](https://vega.github.io/vega/docs/transforms/aggregate/#ops)
for more details.
-}
type Operation
    = ArgMax
    | ArgMin
    | Average
    | CI0
    | CI1
    | Count
    | Distinct
    | Max
    | Mean
    | Median
    | Min
    | Missing
    | Q1
    | Q3
    | Stderr
    | Stdev
    | StdevP
    | Sum
    | Valid
    | Variance
    | VarianceP


{-| Type of overlap strategy to be applied when there is not space to show all
items on an axis. See the
[Vega documentation](https://vega.github.io/vega/docs/axes)
for more details.
-}
type OverlapStrategy
    = ONone
    | OParity
    | OGreedy


{-| Represents padding dimensions in pixel units. `PSize` will set the same value
on all four edges of a rectangular container while `PEdges` can be used to specify
different sizes on each edge in order _left_, _top_, _right_, _bottom_.
-}
type Padding
    = PSize Float
    | PEdges Float Float Float Float


{-| Type of scale range. Can be used to set the default type of range to use
in a scale. The value of the default for each type can be set separately via
config settings. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#range-defaults).
-}
type RangeDefault
    = RWidth
    | RHeight
    | RSymbol
    | RCategory
    | RDiverging
    | ROrdinal
    | RRamp
    | RHeatmap


{-| Used to indicate the type of scale transformation to apply. See the
[Vega documentation](https://vega.github.io/vega/docs/scales/#types) for more details.
-}
type Scale
    = ScLinear
    | ScPow
    | ScSqrt
    | ScLog
    | ScTime
    | ScUtc
    | ScSequential
    | ScOrdinal
    | ScBand
    | ScPoint
    | ScQuantile
    | ScQuantize
    | ScBinLinear
    | ScBinOrdinal
    | ScCustom String


{-| Describes the scale domain (type of data in scale). For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#domain).
-}
type ScaleDomain
    = DNumbers (List Float)
    | DStrings (List String)
      -- TODO: Can we have DateTimes as literals?
      -- TODO: Documentation implies array literals can include signal references as elements. How do we add these?
    | DSignal Signal
    | DData (List DataReference)


{-| Describes the way a scale can be rounded to 'nice' numbers. For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative).
-}
type ScaleNice
    = NMillisecond
    | NSecond
    | NMinute
    | NHour
    | NDay
    | NWeek
    | NMonth
    | NYear
    | NInterval TimeUnit Int
    | IsNice Bool
    | NTickCount Int


{-| Individual scale property. Scale properties are related, but not identical,
to Vega-Lite's `ScaleProperty` which in Vega are more comprehensive and flexible.
Scale Properties characterise the fundamental data-to-visual transformations applied
by the `scale` function. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#properties)
-}
type ScaleProperty
    = SType Scale
    | SDomain ScaleDomain
    | SDomainMax Float
    | SDomainMin Float
    | SDomainMid Float
      -- TODO: Do we need domainRaw? Why not just use SDomain DNumbers [1,2,3] etc.?
    | SRange ScaleRange
    | SReverse Bool
    | SRound Bool
    | SClamp Bool
    | SInterpolate CInterpolate
    | SPadding Float
    | SNice ScaleNice
    | SZero Bool
    | SExponent Float
    | SBase Float
    | SAlign Float
    | SPaddingInner Float
    | SPaddingOuter Float
    | SRangeStep Float


{-| Describes a scale range of scale output values. For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#range).
-}
type ScaleRange
    = RNumbers (List Float)
    | RStrings (List String)
    | RSignal Signal
    | RScheme String (List Float)
    | RData DataReference
    | RStep Float
    | RDefault RangeDefault


{-| Indicates a rectangular side. Can be used to specify an axis position.
[Vega documentation](https://vega.github.io/vega/docs/axes/#orientation)
for more details.
-}
type Side
    = Left
    | Right
    | Top
    | Bottom


type Signal
    = SName String
    | SExpr String


{-| Allow type of sorting to be customised. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#sort).
-}
type SortProperty
    = Ascending
    | Descending
    | Op Operation
    | ByField String


{-| Represents a Vega specification. Specs can be (and usually are) nested.
They can range from a single Boolean value up to the entire Vega specification.
-}
type alias Spec =
    JE.Value


{-| Describes a unit of time. Useful for encoding and transformations. See the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative)
for further details.
-}
type
    -- TODO: Vega-Lite seems to have more time unit options than Vega (e.g. Quarter, Hours etc. - Check spec to see if this is a doc problem or a genuinely restricted set in Vega)
    TimeUnit
    -- TODO: Add UTC prefix option with a utc function (see https://vega.github.io/vega-lite/docs/timeunit.html)
    = Year
    | YearQuarter
    | YearQuarterMonth
    | YearMonth
    | YearMonthDate
    | YearMonthDateHours
    | YearMonthDateHoursMinutes
    | YearMonthDateHoursMinutesSeconds
    | Quarter
    | QuarterMonth
    | Month
    | MonthDate
    | Date
    | Day
    | Hours
    | HoursMinutes
    | HoursMinutesSeconds
    | Minutes
    | MinutesSeconds
    | Seconds
    | SecondsMilliseconds
    | Milliseconds


{-| Represents a value such as a number or reference to a value such as a field label
or transformed value. For details, see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Value)
-}
type
    Value
    -- TODO: Add scale transform options
    = VSignal Signal
    | VColor ColorValue
    | VField FieldValue
    | VNumber Float
    | VString String
    | VBool Bool
    | VNull


{-| Top-level Vega properties. These are for testing purposes only prior to full
Vega spec generatation being made available.
-}
type VProperty
    = VName
    | VDescription
    | VBackground
    | VTitle
    | VWidth
    | VAutosize
    | VHeight
    | VPadding
    | VAutoSize
    | VConfig
    | VSignals
    | VData
    | VScales
    | VProjections
    | VAxes
    | VLegends
    | VMarks
    | VEncode


{-| Declare the way the view is sized. See the
[Vega documentation](https://vega.github.io/vega/docs/specification/#autosize-types)
for details.

    TODO: XXX

-}
autosize : List Autosize -> ( VProperty, Spec )
autosize aus =
    ( VAutosize, JE.object (List.map autosizeProperty aus) )


{-| Create the axes used to visualize spatial scale mappings.

    TODO: XXX

-}
axes : List Spec -> ( VProperty, Spec )
axes axs =
    ( VAxes, JE.list axs )


{-| Create a single axis used to visualize a spatial scale mapping.

    TODO: XXX

-}
axis : String -> Side -> List AxisProperty -> List Spec -> List Spec
axis scName side aProps =
    (::)
        ((AxScale scName :: AxSide side :: aProps |> List.map axisProperty)
            |> JE.object
        )


{-| Create a column of data. A column has a name and a list of values. The final
parameter is the list of any other columns to which this is added.

    dataColumn "Animal" (Strings [ "Cat", "Dog", "Mouse"]) []

-}
dataColumn : String -> DataValues -> List DataColumn -> List DataColumn
dataColumn colName data =
    case data of
        Numbers col ->
            (::) (List.map (\x -> ( colName, JE.float x )) col)

        Strings col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        DateTimes col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        Booleans col ->
            (::) (List.map (\b -> ( colName, JE.bool b )) col)


{-| Declare a data source from a provided list of column values. Each column contains
values of the same type, but columns each with a different type are permitted.
Columns should all contain the same number of items; if not the dataset will be
truncated to the length of the shortest column. The first parameter should be the
name given to the data table for later reference. An optional list for field
formatting instructions can be provided in the second parameter or an empty list
to use the default formatting. See the
[Vega documentation](https://vega.github.io/vega/docs/data/#format)
for details.
The columns themselves are most easily generated with `dataColumn`

    data =
        dataFromColumns "animals" [ Parse [ ( "Year", FDate "%Y" ) ] ]
            << dataColumn "Animal" (Strings [ "Fish", "Dog", "Cat" ])
            << dataColumn "Age" (Numbers [ 28, 12, 6 ])
            << dataColumn "Year" (Strings [ "2010", "2014", "2015" ])

-}
dataFromColumns : String -> List Format -> List DataColumn -> ( VProperty, Spec )
dataFromColumns name fmts cols =
    let
        dataArray =
            cols
                |> transpose
                |> List.map JE.object
                |> JE.list
    in
    if fmts == [] then
        ( VData, JE.object [ ( "name", JE.string name ), ( "values", dataArray ) ] )
    else
        ( VData, JE.object [ ( "name", JE.string name ), ( "values", dataArray ), ( "format", JE.object (List.concatMap format fmts) ) ] )


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    TODO: XXX

-}
height : Float -> ( VProperty, Spec )
height w =
    ( VHeight, JE.float w )


{-| Set the padding around the visualization in pixel units. The way padding is
interpreted will depend on the `autosize` properties. See the
[Vega documentation](https://vega.github.io/vega/docs/specification/)
for details.

    TODO: XXX

-}
padding : Padding -> ( VProperty, Spec )
padding pad =
    ( VPadding, paddingProperty pad )


{-| Create the scales used to map data values to visual properties.

    TODO: XXX

-}
scales : List Spec -> ( VProperty, Spec )
scales scs =
    ( VScales, JE.list scs )


{-| Create a single scale used to map data values to visual properties.

    TODO: XXX

-}
scale : String -> List ScaleProperty -> List Spec -> List Spec
scale name sProps =
    (::)
        (( "name", JE.string name )
            :: List.map scaleProperty sProps
            |> JE.object
        )


{-| Convert a list of Vega specifications into a single JSON object that may be
passed to Vega for graphics generation.
Currently this is a placeholder only and is not available for use.
-}
toVega : List ( VProperty, Spec ) -> Spec
toVega spec =
    ( "$schema", JE.string "https://vega.github.io/schema/vega/v3.0.json" )
        :: List.map (\( s, v ) -> ( vPropertyLabel s, v )) spec
        |> JE.object


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    TODO: XXX

-}
width : Float -> ( VProperty, Spec )
width w =
    ( VWidth, JE.float w )



-- ################################################# Private types and functions


type alias LabelledSpec =
    ( String, Spec )


autosizeProperty : Autosize -> LabelledSpec
autosizeProperty asCfg =
    case asCfg of
        APad ->
            ( "type", JE.string "pad" )

        AFit ->
            ( "type", JE.string "fit" )

        ANone ->
            ( "type", JE.string "none" )

        AResize ->
            ( "resize", JE.bool True )

        AContent ->
            ( "contains", JE.string "content" )

        APadding ->
            ( "contains", JE.string "padding" )


axisProperty : AxisProperty -> LabelledSpec
axisProperty ap =
    case ap of
        AxScale scName ->
            ( "scale", JE.string scName )

        AxSide axSide ->
            ( "orient", JE.string (sideLabel axSide) )

        AxFormat fmt ->
            ( "format", JE.string fmt )

        AxDomain b ->
            ( "domain", JE.bool b )

        AxGrid b ->
            ( "grid", JE.bool b )

        AxLabels b ->
            ( "labels", JE.bool b )

        AxLabelOverlap strat ->
            ( "labelOverlap", JE.string (overlapStrategyLabel strat) )

        AxLabelPadding pad ->
            ( "labelPadding", JE.float pad )

        AxMaxExtent val ->
            ( "maxExtent", value val )

        AxMinExtent val ->
            ( "minExtent", value val )

        AxGridScale scName ->
            ( "gridScale", JE.string scName )

        AxLabelBound numOrNothing ->
            case numOrNothing of
                Nothing ->
                    ( "labelBound", JE.bool False )

                Just x ->
                    ( "labelBound", JE.float x )

        AxLabelFlush numOrNothing ->
            case numOrNothing of
                Nothing ->
                    ( "labelFlush", JE.bool False )

                Just x ->
                    ( "labelFlush", JE.float x )

        AxLabelFlushOffset pad ->
            ( "labelFlushOffset", JE.float pad )

        AxOffset val ->
            ( "offset", value val )

        AxPosition val ->
            ( "position", value val )

        AxTicks b ->
            ( "ticks", JE.bool b )

        AxTickCount n ->
            ( "tickCount", JE.int n )

        AxTickSize sz ->
            ( "tickSize", JE.float sz )

        AxTitle title ->
            ( "title", JE.string title )

        AxTitlePadding pad ->
            ( "titlePadding", JE.float pad )

        AxValues vals ->
            ( "values", JE.list (List.map JE.float vals) )

        AxZIndex n ->
            ( "zindex", JE.int n )


colorProperty : ColorValue -> LabelledSpec
colorProperty cVal =
    case cVal of
        RGB r g b ->
            ( "color", JE.object [ ( "r", JE.float r ), ( "g", JE.float g ), ( "b", JE.float b ) ] )

        HSL h s l ->
            ( "color", JE.object [ ( "h", JE.float h ), ( "s", JE.float s ), ( "l", JE.float l ) ] )

        LAB l a b ->
            ( "color", JE.object [ ( "l", JE.float l ), ( "a", JE.float a ), ( "b", JE.float b ) ] )

        HCL h c l ->
            ( "color", JE.object [ ( "h", JE.float h ), ( "c", JE.float c ), ( "l", JE.float l ) ] )


dataRefProperty : DataReference -> LabelledSpec
dataRefProperty dataRef =
    case dataRef of
        DDataset ds ->
            ( "data", JE.string ds )

        DField df ->
            ( "field", JE.string df )

        DFields dfs ->
            ( "fields", JE.list (List.map JE.string dfs) )

        DReferences drs ->
            ( "fields", JE.object (List.map dataRefProperty drs) )

        DSort sps ->
            if sps == [ Ascending ] then
                ( "sort", JE.bool True )
            else
                ( "sort", JE.object (List.map sortProperty sps) )


fieldValue : FieldValue -> Spec
fieldValue fVal =
    case fVal of
        FName fName ->
            JE.string fName

        FSignal sig ->
            JE.object [ signalProperty sig ]

        FDatum fv ->
            JE.object [ ( "datum", fieldValue fv ) ]

        FGroup fv ->
            JE.object [ ( "group", fieldValue fv ) ]

        FParent fv ->
            JE.object [ ( "parent", fieldValue fv ) ]


foDataType : DataType -> Spec
foDataType dType =
    case dType of
        FoNumber ->
            JE.string "number"

        FoBoolean ->
            JE.string "boolean"

        FoDate dateFmt ->
            if dateFmt == "" then
                JE.string "date"
            else
                JE.string ("date:'" ++ dateFmt ++ "'")

        FoUtc dateFmt ->
            if dateFmt == "" then
                JE.string "utc"
            else
                JE.string ("utc:'" ++ dateFmt ++ "'")


format : Format -> List LabelledSpec
format fmt =
    case fmt of
        JSON ->
            [ ( "type", JE.string "json" ) ]

        CSV ->
            [ ( "type", JE.string "csv" ) ]

        TSV ->
            [ ( "type", JE.string "tsv" ) ]

        DSV delim ->
            [ ( "type", JE.string "dsv" ), ( "delimeter", JE.string delim ) ]

        TopojsonFeature objectSet ->
            [ ( "type", JE.string "json" ), ( "feature", JE.string objectSet ) ]

        TopojsonMesh objectSet ->
            [ ( "type", JE.string "json" ), ( "mesh", JE.string objectSet ) ]

        Parse fmts ->
            [ ( "parse", JE.object <| List.map (\( field, fmt ) -> ( field, foDataType fmt )) fmts ) ]


interpolateProperty : CInterpolate -> Spec
interpolateProperty iType =
    case iType of
        Rgb gamma ->
            JE.object [ ( "type", JE.string "rgb" ), ( "gamma", JE.float gamma ) ]

        Hsl ->
            JE.object [ ( "type", JE.string "hsl" ) ]

        HslLong ->
            JE.object [ ( "type", JE.string "hsl-long" ) ]

        Lab ->
            JE.object [ ( "type", JE.string "lab" ) ]

        Hcl ->
            JE.object [ ( "type", JE.string "hcl" ) ]

        HclLong ->
            JE.object [ ( "type", JE.string "hcl-long" ) ]

        CubeHelix gamma ->
            JE.object [ ( "type", JE.string "cubehelix" ), ( "gamma", JE.float gamma ) ]

        CubeHelixLong gamma ->
            JE.object [ ( "type", JE.string "cubehelix-long" ), ( "gamma", JE.float gamma ) ]


nice : ScaleNice -> Spec
nice ni =
    case ni of
        NMillisecond ->
            JE.string "millisecond"

        NSecond ->
            JE.string "second"

        NMinute ->
            JE.string "minute"

        NHour ->
            JE.string "hour"

        NDay ->
            JE.string "day"

        NWeek ->
            JE.string "week"

        NMonth ->
            JE.string "month"

        NYear ->
            JE.string "year"

        NInterval tu step ->
            JE.object [ ( "interval", JE.string (timeUnitLabel tu) ), ( "step", JE.int step ) ]

        IsNice b ->
            JE.bool b

        NTickCount n ->
            JE.int n


opLabel : Operation -> String
opLabel op =
    case op of
        ArgMax ->
            "argmax"

        ArgMin ->
            "argmin"

        Average ->
            "average"

        Count ->
            "count"

        CI0 ->
            "ci0"

        CI1 ->
            "ci1"

        Distinct ->
            "distinct"

        Max ->
            "max"

        Mean ->
            "mean"

        Median ->
            "median"

        Min ->
            "min"

        Missing ->
            "missing"

        Q1 ->
            "q1"

        Q3 ->
            "q3"

        Stdev ->
            "stdev"

        StdevP ->
            "stdevp"

        Sum ->
            "sum"

        Stderr ->
            "stderr"

        Valid ->
            "valid"

        Variance ->
            "variance"

        VarianceP ->
            "variancep"


overlapStrategyLabel : OverlapStrategy -> String
overlapStrategyLabel strat =
    case strat of
        ONone ->
            "false"

        OParity ->
            "parity"

        OGreedy ->
            "greedy"


sideLabel : Side -> String
sideLabel orient =
    case orient of
        Left ->
            "left"

        Bottom ->
            "bottom"

        Right ->
            "right"

        Top ->
            "top"


paddingProperty : Padding -> Spec
paddingProperty pad =
    case pad of
        PSize p ->
            JE.float p

        PEdges l t r b ->
            JE.object
                [ ( "left", JE.float l )
                , ( "top", JE.float t )
                , ( "right", JE.float r )
                , ( "bottom", JE.float b )
                ]


rangeDefaultLabel : RangeDefault -> String
rangeDefaultLabel rd =
    case rd of
        RWidth ->
            "width"

        RHeight ->
            "height"

        RSymbol ->
            "symbol"

        RCategory ->
            "category"

        RDiverging ->
            "diverging"

        ROrdinal ->
            "ordinal"

        RRamp ->
            "ramp"

        RHeatmap ->
            "heatmap"


scaleDomainProperty : ScaleDomain -> Spec
scaleDomainProperty sdType =
    case sdType of
        DNumbers nums ->
            JE.list (List.map JE.float nums)

        DStrings cats ->
            JE.list (List.map JE.string cats)

        DSignal signal ->
            JE.object [ signalProperty signal ]

        DData dataRef ->
            JE.object (List.map dataRefProperty dataRef)


scaleLabel : Scale -> String
scaleLabel scType =
    case scType of
        ScLinear ->
            "linear"

        ScPow ->
            "pow"

        ScSqrt ->
            "sqrt"

        ScLog ->
            "log"

        ScTime ->
            "time"

        ScUtc ->
            "utc"

        ScSequential ->
            "sequential"

        ScOrdinal ->
            "ordinal"

        ScBand ->
            "band"

        ScPoint ->
            "point"

        ScBinLinear ->
            "bin-linear"

        ScBinOrdinal ->
            "bin-ordinal"

        ScQuantile ->
            "quantile"

        ScQuantize ->
            "quantize"

        ScCustom s ->
            s


scaleProperty : ScaleProperty -> LabelledSpec
scaleProperty scaleProp =
    case scaleProp of
        SType sType ->
            ( "type", JE.string (scaleLabel sType) )

        SDomain sdType ->
            ( "domain", scaleDomainProperty sdType )

        SDomainMax sdMax ->
            ( "domainMax", JE.float sdMax )

        SDomainMin sdMin ->
            ( "domainMin", JE.float sdMin )

        SDomainMid sdMid ->
            ( "domainMid", JE.float sdMid )

        SRange range ->
            case range of
                RNumbers xs ->
                    ( "range", JE.list (List.map JE.float xs) )

                RStrings ss ->
                    ( "range", JE.list (List.map JE.string ss) )

                RSignal sig ->
                    ( "range", JE.object [ signalProperty sig ] )

                RScheme name extent ->
                    ( "range", JE.object [ schemeProperty name extent ] )

                RData dRef ->
                    ( "range", JE.object [ dataRefProperty dRef ] )

                RStep step ->
                    ( "range", JE.object [ ( "step", JE.float step ) ] )

                RDefault rd ->
                    ( "range", JE.string (rangeDefaultLabel rd) )

        SPadding x ->
            ( "padding", JE.float x )

        SPaddingInner x ->
            ( "paddingInner", JE.float x )

        SPaddingOuter x ->
            ( "paddingOuter", JE.float x )

        SRangeStep x ->
            ( "rangeStep", JE.float x )

        SRound b ->
            ( "round", JE.bool b )

        SClamp b ->
            ( "clamp", JE.bool b )

        SInterpolate interp ->
            ( "interpolate", interpolateProperty interp )

        SNice ni ->
            ( "nice", nice ni )

        SZero b ->
            ( "zero", JE.bool b )

        SReverse b ->
            ( "reverse", JE.bool b )

        SExponent x ->
            ( "exponent", JE.float x )

        SBase x ->
            ( "base", JE.float x )

        SAlign x ->
            ( "align", JE.float x )


schemeProperty : String -> List Float -> LabelledSpec
schemeProperty name extent =
    case extent of
        [ mn, mx ] ->
            ( "scheme", JE.object [ ( "name", JE.string name ), ( "extent", JE.list [ JE.float mn, JE.float mx ] ) ] )

        _ ->
            ( "scheme", JE.string name )


signalProperty : Signal -> LabelledSpec
signalProperty signal =
    case signal of
        SName sName ->
            ( "signal", JE.string sName )

        SExpr sExpr ->
            -- TODO: Should we check the expression for validity in any way?
            ( "signal", JE.string sExpr )


sortProperty : SortProperty -> LabelledSpec
sortProperty sp =
    case sp of
        Ascending ->
            ( "order", JE.string "ascending" )

        Descending ->
            ( "order", JE.string "descending" )

        ByField field ->
            ( "field", JE.string field )

        Op op ->
            ( "op", JE.string (opLabel op) )


timeUnitLabel : TimeUnit -> String
timeUnitLabel tu =
    case tu of
        Year ->
            "year"

        YearQuarter ->
            "yearquarter"

        YearQuarterMonth ->
            "yearquartermonth"

        YearMonth ->
            "yearmonth"

        YearMonthDate ->
            "yearmonthdate"

        YearMonthDateHours ->
            "yearmonthdatehours"

        YearMonthDateHoursMinutes ->
            "yearmonthdatehoursminutes"

        YearMonthDateHoursMinutesSeconds ->
            "yearmonthdatehoursminutesseconds"

        Quarter ->
            "quarter"

        QuarterMonth ->
            "quartermonth"

        Month ->
            "month"

        MonthDate ->
            "monthdate"

        Date ->
            "date"

        Day ->
            "day"

        Hours ->
            "hours"

        HoursMinutes ->
            "hoursminutes"

        HoursMinutesSeconds ->
            "hoursminutesseconds"

        Minutes ->
            "minutes"

        MinutesSeconds ->
            "minutesseconds"

        Seconds ->
            "seconds"

        SecondsMilliseconds ->
            "secondsmilliseconds"

        Milliseconds ->
            "milliseconds"


transpose : List (List a) -> List (List a)
transpose ll =
    case ll of
        [] ->
            []

        [] :: xss ->
            transpose xss

        (x :: xs) :: xss ->
            let
                heads =
                    List.filterMap List.head xss

                tails =
                    List.filterMap List.tail xss
            in
            (x :: heads) :: transpose (xs :: tails)


value : Value -> Spec
value val =
    case val of
        VSignal sig ->
            JE.object [ signalProperty sig ]

        VColor cVal ->
            JE.object [ colorProperty cVal ]

        VField fName ->
            fieldValue fName

        VNumber num ->
            JE.float num

        VString str ->
            JE.string str

        VBool b ->
            JE.bool b

        VNull ->
            JE.null



-- type Value
--     = VSignal Signal
--     | VColor ColorValue
--     | VField FieldValue
--     | VNumber Float
--     | VString String
--     | VBool Bool
--     | VNull


vPropertyLabel : VProperty -> String
vPropertyLabel spec =
    case spec of
        VName ->
            "name"

        VDescription ->
            "description"

        VBackground ->
            "background"

        VTitle ->
            "title"

        VWidth ->
            "width"

        VAutosize ->
            "autosize"

        VHeight ->
            "height"

        VPadding ->
            "padding"

        VAutoSize ->
            "autosize"

        VConfig ->
            "config"

        VSignals ->
            "signals"

        VData ->
            "data"

        VScales ->
            "scales"

        VProjections ->
            "projections"

        VAxes ->
            "axes"

        VLegends ->
            "legends"

        VMarks ->
            "marks"

        VEncode ->
            "encode"
