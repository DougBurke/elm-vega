module Vega
    exposing
        ( --  Spec
          VProperty
        , toVega
        )

{-| This module will allow you to create a full Vega specification in Elm. A
specification is stored as a JSON object and contains sufficient declarative detail
to specify the graphical output. While this a 'pure' Elm library, to create the
graphical output you probably want to send a Vega specification generated by
`toVega` via a port to some JavaScript that invokes the Vega runtime.


# Creating A Vega Specification

Future development of this package will allow full Vega specifications to be provided.
Currently, only a very limited set of Vega options detailed below, is provided for
testing purposes only.

@docs toVega
@docs VProperty

-}

--import Json.Decode as JD

import Json.Encode as JE


{-| Represents a single column of data. Used when generating inline data with
`dataColumn`.
-}
type alias DataColumn =
    List LabelledSpec


{-| Indicates the type of data to be parsed when reading input data. For `FoDate`
and `FoUtc`, the formatting specification can be specified using
[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format) or
left as an empty string if default date formatting is to be applied. Care should
be taken when assuming default parsing of dates though as different browsers can
parse dates differently. Being explicit about the date format is usually safer.
-}
type DataType
    = FoNumber
    | FoBoolean
    | FoDate String
    | FoUtc String


{-| A list of data values. This is used when a function can accept lists of
different types (e.g. either a list of numbers or a list of strings).
TODO: Check DateTimes only accept strings.
-}
type DataValues
    = Booleans (List Bool)
    | DateTimes (List String)
    | Numbers (List Float)
    | Strings (List String)


{-| Specifies the type of format a data source uses. For details see the
[Vega documentation](https://vega.github.io/vega/docs/data/#format).
-}
type Format
    = JSON
    | CSV
    | TSV
    | DSV String
    | TopojsonFeature String
    | TopojsonMesh String
    | Parse (List ( String, DataType ))


{-| Represents a Vega specification. Specs can be (and usually are) nested.
They can range from a single Boolean value up to the entire Vega specification.
-}
type alias Spec =
    JE.Value


{-| Top-level Vega properties. These are for testing purposes only prior to full
Vega spec generatation being made available.
-}
type VProperty
    = VName
    | VDescription
    | VBackground
    | VTitle
    | VWidth
    | VHeight
    | VPadding
    | VAutoSize
    | VConfig
    | VSignals
    | VData
    | VScales
    | VProjections
    | VAxes
    | VLegends
    | VMarks
    | VEncode


{-| Create a column of data. A column has a name and a list of values. The final
parameter is the list of any other columns to which this is added.

    dataColumn "Animal" (Strings [ "Cat", "Dog", "Mouse"]) []

-}
dataColumn : String -> DataValues -> List DataColumn -> List DataColumn
dataColumn colName data =
    case data of
        Numbers col ->
            (::) (List.map (\x -> ( colName, JE.float x )) col)

        Strings col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        DateTimes col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        Booleans col ->
            (::) (List.map (\b -> ( colName, JE.bool b )) col)


{-| Declare a data source from a provided list of column values. Each column contains
values of the same type, but columns each with a different type are permitted.
Columns should all contain the same number of items; if not the dataset will be
truncated to the length of the shortest column. The first parameter should be the
name given to the data table for later reference. An optional list for field
formatting instructions can be provided in the second parameter or an empty list
to use the default formatting. See the
[Vega documentation](https://vega.github.io/vega/docs/data/#format)
for details.
The columns themselves are most easily generated with `dataColumn`

    data =
        dataFromColumns "animals" [ Parse [ ( "Year", FDate "%Y" ) ] ]
            << dataColumn "Animal" (Strings [ "Fish", "Dog", "Cat" ])
            << dataColumn "Age" (Numbers [ 28, 12, 6 ])
            << dataColumn "Year" (Strings [ "2010", "2014", "2015" ])

-}
dataFromColumns : String -> List Format -> List DataColumn -> ( VProperty, Spec )
dataFromColumns name fmts cols =
    let
        dataArray =
            cols
                |> transpose
                |> List.map JE.object
                |> JE.list
    in
    if fmts == [] then
        ( VData, JE.object [ ( "name", JE.string name ), ( "values", dataArray ) ] )
    else
        ( VData, JE.object [ ( "name", JE.string name ), ( "values", dataArray ), ( "format", JE.object (List.concatMap format fmts) ) ] )


{-| Convert a list of Vega specifications into a single JSON object that may be
passed to Vega for graphics generation.
Currently this is a placeholder only and is not available for use.
-}
toVega : List ( VProperty, Spec ) -> Spec
toVega spec =
    ( "$schema", JE.string "https://vega.github.io/schema/vega/v3.0.json" )
        :: List.map (\( s, v ) -> ( vPropertyLabel s, v )) spec
        |> JE.object



-- ################################################# Private types and functions


type alias LabelledSpec =
    ( String, Spec )


foDataType : DataType -> Spec
foDataType dType =
    case dType of
        FoNumber ->
            JE.string "number"

        FoBoolean ->
            JE.string "boolean"

        FoDate dateFmt ->
            if dateFmt == "" then
                JE.string "date"
            else
                JE.string ("date:'" ++ dateFmt ++ "'")

        FoUtc dateFmt ->
            if dateFmt == "" then
                JE.string "utc"
            else
                JE.string ("utc:'" ++ dateFmt ++ "'")


format : Format -> List LabelledSpec
format fmt =
    case fmt of
        JSON ->
            [ ( "type", JE.string "json" ) ]

        CSV ->
            [ ( "type", JE.string "csv" ) ]

        TSV ->
            [ ( "type", JE.string "tsv" ) ]

        DSV delim ->
            [ ( "type", JE.string "dsv" ), ( "delimeter", JE.string delim ) ]

        TopojsonFeature objectSet ->
            [ ( "type", JE.string "json" ), ( "feature", JE.string objectSet ) ]

        TopojsonMesh objectSet ->
            [ ( "type", JE.string "json" ), ( "mesh", JE.string objectSet ) ]

        Parse fmts ->
            [ ( "parse", JE.object <| List.map (\( field, fmt ) -> ( field, foDataType fmt )) fmts ) ]


transpose : List (List a) -> List (List a)
transpose ll =
    case ll of
        [] ->
            []

        [] :: xss ->
            transpose xss

        (x :: xs) :: xss ->
            let
                heads =
                    List.filterMap List.head xss

                tails =
                    List.filterMap List.tail xss
            in
            (x :: heads) :: transpose (xs :: tails)


vPropertyLabel : VProperty -> String
vPropertyLabel spec =
    case spec of
        VName ->
            "name"

        VDescription ->
            "description"

        VBackground ->
            "background"

        VTitle ->
            "title"

        VWidth ->
            "width"

        VHeight ->
            "height"

        VPadding ->
            "padding"

        VAutoSize ->
            "autosize"

        VConfig ->
            "config"

        VSignals ->
            "signals"

        VData ->
            "data"

        VScales ->
            "scales"

        VProjections ->
            "projections"

        VAxes ->
            "axes"

        VLegends ->
            "legends"

        VMarks ->
            "marks"

        VEncode ->
            "encode"
